using System;

namespace Prowl.Slang;

/*

/// <summary>
/// Severity of a diagnostic generated by the compiler.
/// Values come from the enum below, with higher values representing more severe
/// conditions, and all values >= SLANG_SEVERITY_ERROR indicating compilation
/// failure.
/// </summary>
public enum SlangSeverity
{
    /// <summary>A message that is disabled, filtered out.</summary>
    Disabled = 0,

    /// <summary>An informative message.</summary>
    Note,

    /// <summary>A warning, which indicates a possible problem.</summary>
    Warning,

    /// <summary>An error, indicating that compilation failed.</summary>
    Error,

    /// <summary>An unrecoverable error, which forced compilation to abort.</summary>
    Fatal,

    /// <summary>An internal error, indicating a logic error in the compiler.</summary>
    Internal
}

*/

/*

[Flags]
public enum SlangDiagnosticFlags : int
{
    VerbosePaths = 0x01,
    TreatWarningsAsErrors = 0x02
}

*/

/*

public enum SlangBindableResourceType : int
{
    NonBindable = 0,
    Texture,
    Sampler,
    UniformBuffer,
    StorageBuffer,
}

*/


/// <summary>
/// Compilation targets for a session.
/// </summary>
public enum SlangCompileTarget : int
{
#pragma warning disable CS1591
    Unknown,

    None,

    Glsl,

    /*
    /// <summary>
    /// Deprecated and removed: just use <see cref="Glsl"/>.
    /// </summary>
    GlslVulkanDeprecated = 3,

    /// <summary>
    /// Deprecated and removed.
    /// </summary>
    GlslVulkanOneDescDeprecated = 4,
    */

    Hlsl = 5,

    Spirv,

    SpirvAsm,

    Dxbc,

    DxbcAsm,

    Dxil,

    DxilAsm,

    /// <summary>
    /// The C language
    /// </summary>
    CSource,

    /// <summary>
    /// C++ code for shader kernels.
    /// </summary>
    CppSource,

    /// <summary>
    /// Standalone binary executable (for hosting CPU/OS)
    /// </summary>
    HostExecutable,

    /// <summary>
    /// A shared library/Dll for shader kernels (for hosting CPU/OS)
    /// </summary>
    ShaderSharedLibrary,

    /// <summary>
    /// A CPU target that makes the compiled shader code available to be run immediately
    /// </summary>
    ShaderHostCallable,

    /// <summary>
    /// Cuda source
    /// </summary>
    CudaSource,

    /// <summary>
    /// PTX
    /// </summary>
    Ptx,

    /// <summary>
    /// Object code that contains CUDA functions.
    /// </summary>
    CudaObjectCode,

    /// <summary>
    /// Object code that can be used for later linking
    /// </summary>
    ObjectCode,

    /// <summary>
    /// C++ code for host library or executable.
    /// </summary>
    HostCppSource,

    /// <summary>
    /// Host callable host code (i.e., non kernel/shader)
    /// </summary>
    HostHostCallable,

    /// <summary>
    /// C++ PyTorch binding code.
    /// </summary>
    CppPytorchBinding,

    /// <summary>
    /// Metal shading language
    /// </summary>
    Metal,

    /// <summary>
    /// Metal library
    /// </summary>
    MetalLib,

    /// <summary>
    /// Metal library assembly
    /// </summary>
    MetalLibAsm,

    /// <summary>
    /// A shared library/Dll for host code (for hosting CPU/OS)
    /// </summary>
    HostSharedLibrary,

    /// <summary>
    /// WebGPU shading language
    /// </summary>
    Wgsl,

    /// <summary>
    /// SPIR-V assembly via WebGPU shading language
    /// </summary>
    WgslSpirvAsm,

    /// <summary>
    /// SPIR-V via WebGPU shading language
    /// </summary>
    WgslSpirv,
#pragma warning restore CS1591
}

/*

/// A "container format" describes the way that the outputs
/// for multiple files, entry points, targets, etc. should be
/// combined into a single artifact for output.
public enum SlangContainerFormat : int
{
    /// Don't generate a container.
    NONE,

    /// Generate a container in the `.slang-module` format,
    /// which includes reflection information, compiled kernels, etc.
    SLANG_MODULE,
}

*/


/// <summary>
/// Downstream compiler definitions that Slang is able to use as passthrough compilers.
/// </summary>
public enum SlangPassThrough : int
{
    /// <summary>
    /// No passthrough compiler.
    /// </summary>
    None,

    /// <summary>
    /// Microsoft Effects Compiler - DXBC
    /// </summary>
    FXC,

    /// <summary>
    /// DirectX Shader Compiler - DXIL
    /// </summary>
    DXC,

    /// <summary>
    /// Khronos-reference GLSL compiler
    /// </summary>
    Glslang,

    /// <summary>
    /// SPIRV-Disassembler
    /// </summary>
    SpirvDis,

    /// <summary>
    /// Clang C/C++ compiler
    /// </summary>
    Clang,

    /// <summary>
    /// Visual studio C/C++ compiler
    /// </summary>
    VisualStudio,

    /// <summary>
    /// GCC C/C++ compiler
    /// </summary>
    GCC,

    /// <summary>
    /// Generic C or C++ compiler, which is decided by the
    /// source type
    /// </summary>
    Generic_C_Cpp,

    /// <summary>
    /// NVRTC Cuda compiler
    /// </summary>
    NVRTC,

    /// <summary>
    /// LLVM 'compiler' - includes LLVM and Clang
    /// </summary>
    LLVM,

    /// <summary>
    /// SPIRV optimizer
    /// </summary>
    SpirvOpt,

    /// <summary>
    /// Metal compiler
    /// </summary>
    Metal,

    /// <summary>
    /// Tint WGSL compiler
    /// </summary>
    Tint,

    /// <summary>
    /// SPIRV linker
    /// </summary>
    SpirvLink,
}


internal enum SlangArchiveType : int
{
    Undefined,

    Zip,

    Riff,

    RiffDeflate,

    RiffLz4,
}


/*
/// Flags to control compilation behavior.

[Flags]
public enum SlangCompileFlags : uint
{
    /// Do as little mangling of names as possible, to try to preserve original names
    NO_MANGLING = 1 << 3,

    /// Skip code generation step, just check the code and generate layout
    NO_CODEGEN = 1 << 4,

    /// Obfuscate shader names on release products
    OBFUSCATE = 1 << 5,

    /// Deprecated flags: kept around to allow existing applications to
    /// compile. Note that the relevant features will still be left in
    /// their default state.
    NO_CHECKING = 0,
    SPLIT_MIXED_TYPES = 0,
}

*/


/// <summary>
/// Flags to control code generation behavior of a compilation target.
/// </summary>
[Flags]
public enum SlangTargetFlags : uint
{
    /* When compiling for a D3D Shader Model 5.1 or higher target, allocate
       distinct register spaces for parameter blocks.

       @deprecated This behavior is now enabled unconditionally.
    */
    // PARAMETER_BLOCKS_USE_REGISTER_SPACES = 1 << 4,

    /// <summary>
    /// When set, will generate target code that contains all entrypoints defined
    /// in the input source in a single output module (library/source file).
    /// </summary>
    GenerateWholeProgram = 1 << 8,

    /// <summary>
    /// When set, will dump out the IR between intermediate compilation steps.
    /// </summary>
    DumpIR = 1 << 9,

    // GENERATE_SPIRV_DIRECTLY = 1 << 10,
    // Default = GENERATE_SPIRV_DIRECTLY
}


/// <summary>
/// Options to control floating-point precision guarantees for a target.
/// </summary>
public enum SlangFloatingPointMode : uint
{
    /// <summary>
    /// Default floating-point behavior for the target platform.
    /// </summary>
    Default = 0,

    /// <summary>
    /// Fast floating-point arithmetic (`mediump`/`lowp` in GLSL, `half`/`min` in HLSL, `half`/`short` in Metal)
    /// </summary>
    Fast,

    /// <summary>
    /// Precise floating-point arithmentic  (`highp` in GLSL, `float` in HLSL, `float` in Metal)
    /// </summary>
    Precise,
}


/// <summary>
/// Options to control emission of `#line` directives.
/// </summary>
public enum SlangLineDirectiveMode : uint
{
    /// <summary>
    /// Default behavior: pick behavior base on target.
    /// </summary>
    Default = 0,

    /// <summary>
    /// Don't emit line directives at all.
    /// </summary>
    None,

    /// <summary>
    /// Emit standard C-style `#line` directives.
    /// </summary>
    Standard,

    /// <summary>
    /// Emit GLSL-style directives with file *number* instead of name.
    /// </summary>
    GLSL,

    /// <summary>
    /// Use a source map to track line mappings (ie no #line will appear in emitting source).
    /// </summary>
    SourceMap,
}


/// <summary>
/// Source languages used for passthrough compilation.
/// </summary>
public enum SlangSourceLanguage : int
{
#pragma warning disable CS1591
    Unknown,
    Slang,
    HLSL,
    GLSL,
    C,
    CPP,
    CUDA,
    SPIRV,
    Metal,
    WGSL,
#pragma warning restore CS1591
}


/// <summary>
/// Identifier for a shader profile. This enum cannot be used on its own, and must be queried VIA <see cref="GlobalSession.FindProfile(string)"/> .
/// </summary>
public enum SlangProfileID : uint
{
    /// <summary>
    /// Unknown profile.
    /// </summary>
    Unknown,
}


/// <summary>
/// Identifier for a shader profile. This enum cannot be used on its own, and must be queried VIA <see cref="GlobalSession.FindCapability(string)"/> .
/// </summary>
public enum SlangCapabilityID : int
{
    /// <summary>
    /// Unknown capability.
    /// </summary>
    Unknown = 0,
}


/// <summary>
/// The matrix layout mode in memory.
/// </summary>
public enum SlangMatrixLayoutMode : uint
{
    /// <summary>
    /// Determined by compiler or runtime.
    /// </summary>
    Unknown = 0,

    /// <summary>
    /// Row-major memory layout.
    /// </summary>
    RowMajor,

    /// <summary>
    /// Column-major memory layout.
    /// </summary>
    ColumnMajor,
}


/// <summary>
/// Possible shader stages an entrypoint can target.
/// </summary>
public enum ShaderStage : uint
{
#pragma warning disable CS1591
    None,
    Vertex,
    Hull,
    Domain,
    Geometry,
    Fragment,
    Compute,
    RayGeneration,
    Intersection,
    AnyHit,
    ClosestHit,
    Miss,
    Callable,
    Mesh,
    Amplification
#pragma warning restore CS1591
}

/*

public enum SlangDebugInfoLevel : uint
{
    NONE = 0,   /// < Don't emit debug information at all.
    MINIMAL,    /// < Emit as little debug information as possible, while
                ///                                  still supporting stack trackers.
    STANDARD,   /// < Emit whatever is the standard level of debug
                ///                              information for each target.
    MAXIMAL,    /// < Emit as much debug information as possible for each
                ///                                 target.
}

*/


/*

/// <summary>
/// Describes the debugging information format produced during a compilation.
/// </summary>
public enum SlangDebugInfoFormat : uint
{
    DEFAULT, ///< Use the default debugging format for the target
    C7,  ///< CodeView C7 format (typically means debugging information
         ///< is embedded in the binary)
    PDB, ///< Program database

    STABS, ///< Stabs
    COFF,  ///< COFF debug info
    DWARF, ///< DWARF debug info (we may want to support specifying the
           ///< version)
}

*/

/*

public enum SlangOptimizationLevel : uint
{
    NONE = 0,   /// < Don't optimize at all.
    DEFAULT,    /// < Default optimization level: balance code quality and
                ///                                    compilation time.
    HIGH,       /// < Optimize aggressively.
    MAXIMAL,    /// < Include optimizations that may take a very long time,
                ///                                or may involve severe space-vs-speed tradeoffs
}

*/

/*

public enum SlangEmitSpirvMethod : int
{
    DEFAULT = 0,
    VIA_GLSL,
    DIRECTLY,
}

*/

public enum CompilerOptionName : int
{
    MacroDefine, // stringValue0: macro name;  stringValue1: macro value
    DepFile,
    EntryPointName,
    Specialize,
    Help,
    HelpStyle,
    Include, // stringValue: additional include path.
    Language,
    MatrixLayoutColumn,         // bool
    MatrixLayoutRow,            // bool
    ZeroInitialize,             // bool
    IgnoreCapabilities,         // bool
    RestrictiveCapabilityCheck, // bool
    ModuleName,                 // stringValue0: module name.
    Output,
    Profile, // intValue0: profile
    Stage,   // intValue0: stage
    Target,  // intValue0: CodeGenTarget
    Version,
    WarningsAsErrors, // stringValue0: "all" or comma separated list of warning codes or names.
    DisableWarnings,  // stringValue0: comma separated list of warning codes or names.
    EnableWarning,    // stringValue0: warning code or name.
    DisableWarning,   // stringValue0: warning code or name.
    DumpWarningDiagnostics,
    InputFilesRemain,
    EmitIr,                        // bool
    ReportDownstreamTime,          // bool
    ReportPerfBenchmark,           // bool
    ReportCheckpointIntermediates, // bool
    SkipSPIRVValidation,           // bool
    SourceEmbedStyle,
    SourceEmbedName,
    SourceEmbedLanguage,
    DisableShortCircuit,            // bool
    MinimumSlangOptimization,       // bool
    DisableNonEssentialValidations, // bool
    DisableSourceMap,               // bool
    UnscopedEnum,                   // bool
    PreserveParameters, // bool: preserve all resource parameters in the output code.

    // Target

    Capability,                // intValue0: CapabilityName
    DefaultImageFormatUnknown, // bool
    DisableDynamicDispatch,    // bool
    DisableSpecialization,     // bool
    FloatingPointMode,         // intValue0: FloatingPointMode
    DebugInformation,          // intValue0: DebugInfoLevel
    LineDirectiveMode,
    Optimization, // intValue0: OptimizationLevel
    Obfuscate,    // bool

    VulkanBindShift, // intValue0 (higher 8 bits): kind; intValue0(lower bits): set; intValue1:
                     // shift
    VulkanBindGlobals,       // intValue0: index; intValue1: set
    VulkanInvertY,           // bool
    VulkanUseDxPositionW,    // bool
    VulkanUseEntryPointName, // bool
    VulkanUseGLLayout,       // bool
    VulkanEmitReflection,    // bool

    GLSLForceScalarLayout,   // bool
    EnableEffectAnnotations, // bool

    EmitSpirvViaGLSL,     // bool (will be deprecated)
    EmitSpirvDirectly,    // bool (will be deprecated)
    SPIRVCoreGrammarJSON, // stringValue0: json path
    IncompleteLibrary,    // bool, when set, will not issue an error when the linked program has
                          // unresolved extern function symbols.

    // Downstream

    CompilerPath,
    DefaultDownstreamCompiler,
    DownstreamArgs, // stringValue0: downstream compiler name. stringValue1: argument list, one
                    // per line.
    PassThrough,

    // Repro

    DumpRepro,
    DumpReproOnError,
    ExtractRepro,
    LoadRepro,
    LoadReproDirectory,
    ReproFallbackDirectory,

    // Debugging

    DumpAst,
    DumpIntermediatePrefix,
    DumpIntermediates, // bool
    DumpIr,            // bool
    DumpIrIds,
    PreprocessorOutput,
    OutputIncludes,
    ReproFileSystem,
    SerialIr,    // bool
    SkipCodeGen, // bool
    ValidateIr,  // bool
    VerbosePaths,
    VerifyDebugSerialIr,
    NoCodeGen, // Not used.

    // Experimental

    FileSystem,
    Heterogeneous,
    NoMangle,
    NoHLSLBinding,
    NoHLSLPackConstantBufferElements,
    ValidateUniformity,
    AllowGLSL,
    EnableExperimentalPasses,
    BindlessSpaceIndex, // int

    // Internal

    ArchiveType,
    CompileCoreModule,
    Doc,
    IrCompression,
    LoadCoreModule,
    ReferenceModule,
    SaveCoreModule,
    SaveCoreModuleBinSource,
    TrackLiveness,
    LoopInversion, // bool, enable loop inversion optimization

    // Deprecated
    ParameterBlocksUseRegisterSpaces,

    CountOfParsableOptions,

    // Used in parsed options only.
    DebugInformationFormat,  // intValue0: DebugInfoFormat
    VulkanBindShiftAll,      // intValue0: kind; intValue1: shift
    GenerateWholeProgram,    // bool
    UseUpToDateBinaryModule, // bool, when set, will only load
                             // precompiled modules if it is up-to-date with its source.
    EmbedDownstreamIR,       // bool
    ForceDXLayout,           // bool

    // Add this new option to the end of the list to avoid breaking ABI as much as possible.
    // Setting of EmitSpirvDirectly or EmitSpirvViaGLSL will turn into this option internally.
    EmitSpirvMethod, // enum SlangEmitSpirvMethod

    EmitReflectionJSON, // bool
    SaveGLSLModuleBinSource,

    SkipDownstreamLinking, // bool, experimental
    DumpModule,
    CountOf,
}


public enum CompilerOptionValueKind : int
{
    Int,
    String
}


/* Type that identifies how a path should be interpreted */
internal enum SlangPathType : uint
{
    Directory, /// Path specified specifies a directory.
    File,      /// Path specified is to a file.
}

/* Callback to enumerate the contents of of a directory in a ISlangFileSystemExt.
The name is the name of a file system object (directory/file) in the specified path (ie it is
without a path) */
// typedef void (
//         * FileSystemContentsCallBack) (SlangPathType pathType, byte* name, void* userData);

/* Determines how paths map to files on the OS file system */
internal enum OSPathKind : byte
{
    None,            /// Paths do not map to the file system
    Direct,          /// Paths map directly to the file system
    OperatingSystem, /// Only paths gained via PathKind::OperatingSystem map to the operating
                     /// system file system
}

/* Used to determine what kind of path is required from an input path */
internal enum PathKind : int
{
    /// Given a path, returns a simplified version of that path.
    /// This typically means removing '..' and/or '.' from the path.
    /// A simplified path must point to the same object as the original.
    Simplified,

    /// Given a path, returns a 'canonical path' to the item.
    /// This may be the operating system 'canonical path' that is the unique path to the item.
    ///
    /// If the item exists the returned canonical path should always be usable to access the
    /// item.
    ///
    /// If the item the path specifies doesn't exist, the canonical path may not be returnable
    /// or be a path simplification.
    /// Not all file systems support canonical paths.
    Canonical,

    /// Given a path returns a path such that it is suitable to be displayed to the user.
    ///
    /// For example if the file system is a zip file - it might include the path to the zip
    /// container as well as the path to the specific file.
    ///
    /// NOTE! The display path won't necessarily work on the file system to access the item
    Display,

    /// Get the path to the item on the *operating system* file system, if available.
    OperatingSystem,
}


/*

/// <summary>
/// Identifies different types of writer target
/// </summary>
public enum SlangWriterChannel : uint
{
    DIAGNOSTIC,
    STD_OUTPUT,
    STD_ERROR,
}

*/

/*

public enum SlangWriterMode : uint
{
    TEXT,
    BINARY,
};

*/


/*!
@brief Callback type used for diagnostic output.
*/
// typedef void (* SlangDiagnosticCallback) (byte* message, void* userData);

/*
Forward declarations of types used in the reflection interface;
*/

public enum SlangReflectionGenericArgType : int
{
    TYPE = 0,
    INT = 1,
    BOOL = 2
};

// type reflection
public enum SlangTypeKind : uint
{
    NONE,
    STRUCT,
    ARRAY,
    MATRIX,
    VECTOR,
    SCALAR,
    CONSTANT_BUFFER,
    RESOURCE,
    SAMPLER_STATE,
    TEXTURE_BUFFER,
    SHADER_STORAGE_BUFFER,
    PARAMETER_BLOCK,
    GENERIC_TYPE_PARAMETER,
    INTERFACE,
    OUTPUT_STREAM,
    MESH_OUTPUT,
    SPECIALIZED,
    FEEDBACK,
    POINTER,
    DYNAMIC_RESOURCE,
    COUNT,
}


public enum SlangScalarType : uint
{
    NONE,
    VOID,
    BOOL,
    INT32,
    UINT32,
    INT64,
    UINT64,
    FLOAT16,
    FLOAT32,
    FLOAT64,
    INT8,
    UINT8,
    INT16,
    UINT16,
    INTPTR,
    UINTPTR
}


public enum SlangResourceShape : uint
{
    RESOURCE_BASE_SHAPE_MASK = 0x0F,

    RESOURCE_NONE = 0x00,

    TEXTURE_1D = 0x01,
    TEXTURE_2D = 0x02,
    TEXTURE_3D = 0x03,
    TEXTURE_CUBE = 0x04,
    TEXTURE_BUFFER = 0x05,

    STRUCTURED_BUFFER = 0x06,
    BYTE_ADDRESS_BUFFER = 0x07,
    RESOURCE_UNKNOWN = 0x08,
    ACCELERATION_STRUCTURE = 0x09,
    TEXTURE_SUBPASS = 0x0A,

    RESOURCE_EXT_SHAPE_MASK = 0xF0,

    TEXTURE_FEEDBACK_FLAG = 0x10,
    TEXTURE_SHADOW_FLAG = 0x20,
    TEXTURE_ARRAY_FLAG = 0x40,
    TEXTURE_MULTISAMPLE_FLAG = 0x80,

    SLANG_TEXTURE_1D_ARRAY = TEXTURE_1D | TEXTURE_ARRAY_FLAG,
    SLANG_TEXTURE_2D_ARRAY = TEXTURE_2D | TEXTURE_ARRAY_FLAG,
    SLANG_TEXTURE_CUBE_ARRAY = TEXTURE_CUBE | TEXTURE_ARRAY_FLAG,

    SLANG_TEXTURE_2D_MULTISAMPLE = TEXTURE_2D | TEXTURE_MULTISAMPLE_FLAG,
    SLANG_TEXTURE_2D_MULTISAMPLE_ARRAY = TEXTURE_2D | TEXTURE_MULTISAMPLE_FLAG | TEXTURE_ARRAY_FLAG,
    SLANG_TEXTURE_SUBPASS_MULTISAMPLE = TEXTURE_SUBPASS | TEXTURE_MULTISAMPLE_FLAG,
}


public enum SlangResourceAccess : uint
{
    NONE,
    READ,
    READ_WRITE,
    RASTER_ORDERED,
    APPEND,
    CONSUME,
    WRITE,
    FEEDBACK,
    UNKNOWN = 0x7FFFFFFF,
}


public enum SlangParameterCategory : uint
{
    NONE,
    MIXED,
    CONSTANT_BUFFER,
    SHADER_RESOURCE,
    UNORDERED_ACCESS,
    VARYING_INPUT,
    VARYING_OUTPUT,
    SAMPLER_STATE,
    UNIFORM,
    DESCRIPTOR_TABLE_SLOT,
    SPECIALIZATION_CONSTANT,
    PUSH_CONSTANT_BUFFER,

    // HLSL register `space`, Vulkan GLSL `set`
    REGISTER_SPACE,

    // TODO: Ellie, Both APIs treat mesh outputs as more or less varying output,
    // Does it deserve to be represented here??

    // A parameter whose type is to be specialized by a global generic type argument
    GENERIC,

    RAY_PAYLOAD,
    HIT_ATTRIBUTES,
    CALLABLE_PAYLOAD,
    SHADER_RECORD,

    // An existential type parameter represents a "hole" that
    // needs to be filled with a concrete type to enable
    // generation of specialized code.
    //
    // Consider this example:
    //
    //      struct MyParams
    //      {
    //          IMaterial material;
    //          ILight lights[3];
    //      };
    //
    // This `MyParams` type introduces two existential type parameters:
    // one for `material` and one for `lights`. Even though `lights`
    // is an array, it only introduces one type parameter, because
    // we need to have a *single* concrete type for all the array
    // elements to be able to generate specialized code.
    //
    EXISTENTIAL_TYPE_PARAM,

    // An existential object parameter represents a value
    // that needs to be passed in to provide data for some
    // interface-type shader parameter.
    //
    // Consider this example:
    //
    //      struct MyParams
    //      {
    //          IMaterial material;
    //          ILight lights[3];
    //      };
    //
    // This `MyParams` type introduces four existential object parameters:
    // one for `material` and three for `lights` (one for each array
    // element). This is consistent with the number of interface-type
    // "objects" that are being passed through to the shader.
    //
    EXISTENTIAL_OBJECT_PARAM,

    // The register space offset for the sub-elements that occupies register spaces.
    SUB_ELEMENT_REGISTER_SPACE,

    // The input_attachment_index subpass occupancy tracker
    SUBPASS,

    // Metal tier-1 argument buffer element [[id]].
    METAL_ARGUMENT_BUFFER_ELEMENT,

    // Metal [[attribute]] inputs.
    METAL_ATTRIBUTE,

    // Metal [[payload]] inputs
    METAL_PAYLOAD,
}

/// <summary>
/// <para>
/// Types of API-managed bindings that a parameter might use.
/// </para>
/// <para>
/// `SlangBindingType` represents the distinct types of binding ranges that might be
/// understood by an underlying graphics API or cross-API abstraction layer.
/// Several of the enumeration cases here correspond to cases of `VkDescriptorType`
/// defined by the Vulkan API.Note however that the values of this enumeration
/// are not the same as those of any particular API.
/// </para>
/// <para>
/// The `SlangBindingType` enumeration is distinct from `SlangParameterCategory`
/// because `SlangParameterCategory` differentiates the types of parameters for
/// the purposes of layout, where the layout rules of some targets will treat
/// parameters of different types as occupying the same binding space for layout
/// (e.g., in SPIR-V both a `Texture2D` and `SamplerState` use the same space of
/// `binding` indices, and are not allowed to overlap), while those same types
/// map to different types of bindings in the API (e.g., both textures and samplers
/// use different `VkDescriptorType` values).
/// </para>
/// <para>
/// When you want to answer "what register/binding did this parameter use?" you
/// should use `SlangParameterCategory`.
/// </para>
/// <para>
/// When you want to answer "what type of descriptor range should this parameter use?"
/// you should use `SlangBindingType`.
/// </para>
/// </summary>
public enum SlangBindingType : uint
{
    UNKNOWN = 0,

    SAMPLER,
    TEXTURE,
    CONSTANT_BUFFER,
    PARAMETER_BLOCK,
    TYPED_BUFFER,
    RAW_BUFFER,
    COMBINED_TEXTURE_SAMPLER,
    INPUT_RENDER_TARGET,
    INLINE_UNIFORM_DATA,
    RAY_TRACING_ACCELERATION_STRUCTURE,

    VARYING_INPUT,
    VARYING_OUTPUT,

    EXISTENTIAL_VALUE,
    PUSH_CONSTANT,

    MUTABLE_FLAG = 0x100,

    MUTABLE_TETURE = TEXTURE | MUTABLE_FLAG,
    MUTABLE_TYPED_BUFFER = TYPED_BUFFER | MUTABLE_FLAG,
    MUTABLE_RAW_BUFFER = RAW_BUFFER | MUTABLE_FLAG,

    BASE_MASK = 0x00FF,
    EXT_MASK = 0xFF00,
}


public enum SlangLayoutRules : uint
{
    DEFAULT,
    METAL_ARGUMENT_BUFFER_TIER_2,
}


/// <summary>
/// The possible image formats of a shader uniform.
/// </summary>
public enum SlangImageFormat : uint
{
#pragma warning disable CS1591
    Unknown,
    RGBA32Float,
    RGBA16Float,
    RG32Float,
    RG16Float,
    R11Float_G11Float_b10Float,
    R32Float,
    R16Float,
    RGBA16,
    RGB10_A2,
    RGBA8,
    RG16,
    RG8,
    R16,
    R8,
    RGBA16_SNorm,
    RGBA8_SNorm,
    RG16_SNorm,
    RG8_SNorm,
    R16_SNorm,
    R8_SNorm,
    RGBA32Int,
    RGBA16Int,
    RGBA8Int,
    RG32Int,
    RG16Int,
    RG8Int,
    R32Int,
    R16Int,
    R8Int,
    RGBA32UInt,
    RGBA16UInt,
    RGB10_A2UInt,
    RGBA8UInt,
    RG32UInt,
    RG16UInt,
    RG8UInt,
    R32UInt,
    R16UInt,
    R8UInt,
    R64UInt,
    R64Int,
    BGRA8,
#pragma warning restore CS1591
}


internal enum CompileCoreModuleFlags : uint
{
    WriteDocumentation = 0x1,
}


internal enum BuiltinModuleName : int
{
    Core,
    GLSL
}


/// <summary>
/// The container type of a shader variable.
/// </summary>
public enum ContainerType : int
{
    /// <summary>
    /// Variable is not a container.
    /// </summary>
    None,

    /// <summary>
    /// Container is an unsized array.
    /// </summary>
    UnsizedArray,

    /// <summary>
    /// Container is a structured buffer.
    /// </summary>
    StructuredBuffer,

    /// <summary>
    /// Container is a constant buffer.
    /// </summary>
    ConstantBuffer,

    /// <summary>
    /// Container is a parameter block.
    /// </summary>
    ParameterBlock
}


/// <summary>
/// Passed into functions to create globalSession to identify the API version client code is
/// using.
/// </summary>
public enum SlangLanguageVersion : uint
{
    /// <summary>
    /// Language version 2025
    /// </summary>
    _2025 = 2025
}

/// <summary>
/// Flags used when creating a <see cref="Session"/> instance.
/// </summary>
public enum SessionFlags : uint
{
    ///
    None = 0
}
