// This file is part of the Prowl Game Engine
// Licensed under the MIT License. See the LICENSE file in the project root for details.

using System;

namespace Prowl.Slang;


/// <summary>
/// Severity of a diagnostic generated by the compiler.
/// Values come from the enum below, with higher values representing more severe
/// conditions, and all values >= Error indicating compilation
/// failure.
/// </summary>
public enum Severity
{
    /// <summary>
    /// A message that is disabled, filtered out.
    /// </summary>
    Disabled = 0,

    /// <summary>
    /// An informative message.
    /// </summary>
    Note,

    /// <summary>
    /// A warning, which indicates a possible problem.
    /// </summary>
    Warning,

    /// <summary>
    /// An error, indicating that compilation failed.
    /// </summary>
    Error,

    /// <summary>
    /// An unrecoverable error, which forced compilation to abort.
    /// </summary>
    Fatal,

    /// <summary>
    /// An internal error, indicating a logic error in the compiler.
    /// </summary>
    Internal
}

/*

[Flags]
public enum SlangDiagnosticFlags : int
{
    VerbosePaths = 0x01,
    TreatWarningsAsErrors = 0x02
}

*/

/*

public enum SlangBindableResourceType : int
{
    NonBindable = 0,
    Texture,
    Sampler,
    UniformBuffer,
    StorageBuffer,
}

*/


/// <summary>
/// Modifiers that can be applied to a shader variable or function.
/// </summary>
public enum ModifierID : uint
{
#pragma warning disable CS1591
    Shared,
    NoDiff,
    Static,
    Const,
    Export,
    Extern,
    Differentiable,
    Mutating,
    In,
    Out,
    InOut
#pragma warning restore CS1591
}


/// <summary>
/// Compilation targets for a session.
/// </summary>
public enum CompileTarget : int
{
#pragma warning disable CS1591
    Unknown,

    None,

    Glsl,

    /*
    /// <summary>
    /// Deprecated and removed: just use <see cref="Glsl"/>.
    /// </summary>
    GlslVulkanDeprecated = 3,

    /// <summary>
    /// Deprecated and removed.
    /// </summary>
    GlslVulkanOneDescDeprecated = 4,
    */

    Hlsl = 5,

    Spirv,

    SpirvAsm,

    Dxbc,

    DxbcAsm,

    Dxil,

    DxilAsm,

    /// <summary>
    /// The C language
    /// </summary>
    CSource,

    /// <summary>
    /// C++ code for shader kernels.
    /// </summary>
    CppSource,

    /// <summary>
    /// Standalone binary executable (for hosting CPU/OS)
    /// </summary>
    HostExecutable,

    /// <summary>
    /// A shared library/Dll for shader kernels (for hosting CPU/OS)
    /// </summary>
    ShaderSharedLibrary,

    /// <summary>
    /// A CPU target that makes the compiled shader code available to be run immediately
    /// </summary>
    ShaderHostCallable,

    /// <summary>
    /// Cuda source
    /// </summary>
    CudaSource,

    /// <summary>
    /// PTX
    /// </summary>
    Ptx,

    /// <summary>
    /// Object code that contains CUDA functions.
    /// </summary>
    CudaObjectCode,

    /// <summary>
    /// Object code that can be used for later linking
    /// </summary>
    ObjectCode,

    /// <summary>
    /// C++ code for host library or executable.
    /// </summary>
    HostCppSource,

    /// <summary>
    /// Host callable host code (i.e., non kernel/shader)
    /// </summary>
    HostHostCallable,

    /// <summary>
    /// C++ PyTorch binding code.
    /// </summary>
    CppPytorchBinding,

    /// <summary>
    /// Metal shading language
    /// </summary>
    Metal,

    /// <summary>
    /// Metal library
    /// </summary>
    MetalLib,

    /// <summary>
    /// Metal library assembly
    /// </summary>
    MetalLibAsm,

    /// <summary>
    /// A shared library/Dll for host code (for hosting CPU/OS)
    /// </summary>
    HostSharedLibrary,

    /// <summary>
    /// WebGPU shading language
    /// </summary>
    Wgsl,

    /// <summary>
    /// SPIR-V assembly via WebGPU shading language
    /// </summary>
    WgslSpirvAsm,

    /// <summary>
    /// SPIR-V via WebGPU shading language
    /// </summary>
    WgslSpirv,
#pragma warning restore CS1591
}

/*

/// A "container format" describes the way that the outputs
/// for multiple files, entry points, targets, etc. should be
/// combined into a single artifact for output.
public enum SlangContainerFormat : int
{
    /// Don't generate a container.
    NONE,

    /// Generate a container in the `.slang-module` format,
    /// which includes reflection information, compiled kernels, etc.
    SLANG_MODULE,
}

*/


/// <summary>
/// Downstream compiler definitions that Slang is able to use as passthrough compilers.
/// </summary>
public enum PassThrough : int
{
    /// <summary>
    /// No passthrough compiler.
    /// </summary>
    None,

    /// <summary>
    /// Microsoft Effects Compiler - DXBC
    /// </summary>
    FXC,

    /// <summary>
    /// DirectX Shader Compiler - DXIL
    /// </summary>
    DXC,

    /// <summary>
    /// Khronos-reference GLSL compiler
    /// </summary>
    Glslang,

    /// <summary>
    /// SPIRV-Disassembler
    /// </summary>
    SpirvDis,

    /// <summary>
    /// Clang C/C++ compiler
    /// </summary>
    Clang,

    /// <summary>
    /// Visual studio C/C++ compiler
    /// </summary>
    VisualStudio,

    /// <summary>
    /// GCC C/C++ compiler
    /// </summary>
    GCC,

    /// <summary>
    /// Generic C or C++ compiler, which is decided by the
    /// source type
    /// </summary>
    Generic_C_Cpp,

    /// <summary>
    /// NVRTC Cuda compiler
    /// </summary>
    NVRTC,

    /// <summary>
    /// LLVM 'compiler' - includes LLVM and Clang
    /// </summary>
    LLVM,

    /// <summary>
    /// SPIRV optimizer
    /// </summary>
    SpirvOpt,

    /// <summary>
    /// Metal compiler
    /// </summary>
    Metal,

    /// <summary>
    /// Tint WGSL compiler
    /// </summary>
    Tint,

    /// <summary>
    /// SPIRV linker
    /// </summary>
    SpirvLink,
}


internal enum SlangArchiveType : int
{
    Undefined,

    Zip,

    Riff,

    RiffDeflate,

    RiffLz4,
}


/*
/// Flags to control compilation behavior.

[Flags]
public enum SlangCompileFlags : uint
{
    /// Do as little mangling of names as possible, to try to preserve original names
    NO_MANGLING = 1 << 3,

    /// Skip code generation step, just check the code and generate layout
    NO_CODEGEN = 1 << 4,

    /// Obfuscate shader names on release products
    OBFUSCATE = 1 << 5,

    /// Deprecated flags: kept around to allow existing applications to
    /// compile. Note that the relevant features will still be left in
    /// their default state.
    NO_CHECKING = 0,
    SPLIT_MIXED_TYPES = 0,
}

*/


/// <summary>
/// Flags to control code generation behavior of a compilation target.
/// </summary>
[Flags]
public enum TargetFlags : uint
{
    /* When compiling for a D3D Shader Model 5.1 or higher target, allocate
       distinct register spaces for parameter blocks.

       @deprecated This behavior is now enabled unconditionally.
    */
    // PARAMETER_BLOCKS_USE_REGISTER_SPACES = 1 << 4,

    /// <summary>
    /// When set, will generate target code that contains all entrypoints defined
    /// in the input source in a single output module (library/source file).
    /// </summary>
    GenerateWholeProgram = 1 << 8,

    /// <summary>
    /// When set, will dump out the IR between intermediate compilation steps.
    /// </summary>
    DumpIR = 1 << 9,

    ///
    GenerateSpirvDirectly = 1 << 10,

    ///
    Default = GenerateSpirvDirectly,
}


/// <summary>
/// Options to control floating-point precision guarantees for a target.
/// </summary>
public enum FloatingPointMode : uint
{
    /// <summary>
    /// Default floating-point behavior for the target platform.
    /// </summary>
    Default = 0,

    /// <summary>
    /// Fast floating-point arithmetic (`mediump`/`lowp` in GLSL, `half`/`min` in HLSL, `half`/`short` in Metal)
    /// </summary>
    Fast,

    /// <summary>
    /// Precise floating-point arithmentic  (`highp` in GLSL, `float` in HLSL, `float` in Metal)
    /// </summary>
    Precise,
}


/// <summary>
/// Options to control emission of `#line` directives.
/// </summary>
public enum LineDirectiveMode : uint
{
    /// <summary>
    /// Default behavior: pick behavior base on target.
    /// </summary>
    Default = 0,

    /// <summary>
    /// Don't emit line directives at all.
    /// </summary>
    None,

    /// <summary>
    /// Emit standard C-style `#line` directives.
    /// </summary>
    Standard,

    /// <summary>
    /// Emit GLSL-style directives with file *number* instead of name.
    /// </summary>
    GLSL,

    /// <summary>
    /// Use a source map to track line mappings (ie no #line will appear in emitting source).
    /// </summary>
    SourceMap,
}


/// <summary>
/// Source languages used for passthrough compilation.
/// </summary>
public enum SourceLanguage : int
{
#pragma warning disable CS1591
    Unknown,
    Slang,
    HLSL,
    GLSL,
    C,
    CPP,
    CUDA,
    SPIRV,
    Metal,
    WGSL,
#pragma warning restore CS1591
}


/// <summary>
/// Identifier for a shader profile. This enum cannot be used on its own, and must be queried VIA <see cref="GlobalSession.FindProfile(string)"/> .
/// </summary>
public enum ProfileID : uint
{
    /// <summary>
    /// Unknown profile.
    /// </summary>
    Unknown,
}


/// <summary>
/// Identifier for a shader profile. This enum cannot be used on its own, and must be queried VIA <see cref="GlobalSession.FindCapability(string)"/> .
/// </summary>
public enum CapabilityID : int
{
    /// <summary>
    /// Unknown capability.
    /// </summary>
    Unknown = 0,
}


/// <summary>
/// The matrix layout mode in memory.
/// </summary>
public enum MatrixLayoutMode : uint
{
    /// <summary>
    /// Determined by compiler or runtime.
    /// </summary>
    Unknown = 0,

    /// <summary>
    /// Row-major memory layout.
    /// </summary>
    RowMajor,

    /// <summary>
    /// Column-major memory layout.
    /// </summary>
    ColumnMajor,
}


/// <summary>
/// Possible shader stages an entrypoint can target.
/// </summary>
public enum ShaderStage : uint
{
#pragma warning disable CS1591
    None,
    Vertex,
    Hull,
    Domain,
    Geometry,
    Fragment,
    Compute,
    RayGeneration,
    Intersection,
    AnyHit,
    ClosestHit,
    Miss,
    Callable,
    Mesh,
    Amplification
#pragma warning restore CS1591
}

/*

public enum SlangDebugInfoLevel : uint
{
    NONE = 0,   /// < Don't emit debug information at all.
    MINIMAL,    /// < Emit as little debug information as possible, while
                ///                                  still supporting stack trackers.
    STANDARD,   /// < Emit whatever is the standard level of debug
                ///                              information for each target.
    MAXIMAL,    /// < Emit as much debug information as possible for each
                ///                                 target.
}

*/


/*

/// <summary>
/// Describes the debugging information format produced during a compilation.
/// </summary>
public enum SlangDebugInfoFormat : uint
{
    DEFAULT, ///< Use the default debugging format for the target
    C7,  ///< CodeView C7 format (typically means debugging information
         ///< is embedded in the binary)
    PDB, ///< Program database

    STABS, ///< Stabs
    COFF,  ///< COFF debug info
    DWARF, ///< DWARF debug info (we may want to support specifying the
           ///< version)
}

*/

/*

public enum SlangOptimizationLevel : uint
{
    NONE = 0,   /// < Don't optimize at all.
    DEFAULT,    /// < Default optimization level: balance code quality and
                ///                                    compilation time.
    HIGH,       /// < Optimize aggressively.
    MAXIMAL,    /// < Include optimizations that may take a very long time,
                ///                                or may involve severe space-vs-speed tradeoffs
}

*/

/*

public enum SlangEmitSpirvMethod : int
{
    DEFAULT = 0,
    VIA_GLSL,
    DIRECTLY,
}

*/

/// <summary>
/// Types of compiler options that can be specified during session setup.
/// </summary>
public enum CompilerOptionName : int
{
#pragma warning disable CS1591

    /// <summary>
    /// StringValue0: macro name; StringValue1: macro value
    /// </summary>
    MacroDefine,

    DepFile,
    EntryPointName,
    Specialize,
    Help,
    HelpStyle,

    /// <summary>
    /// StringValue: additional include path.
    /// </summary>
    Include,

    Language,

    /// <summary>
    /// bool
    /// </summary>
    MatrixLayoutColumn,

    /// <summary>
    /// bool
    /// </summary>
    MatrixLayoutRow,

    /// <summary>
    /// bool
    /// </summary>
    ZeroInitialize,

    /// <summary>
    /// bool
    /// </summary>
    IgnoreCapabilities,

    /// <summary>
    /// bool
    /// </summary>
    RestrictiveCapabilityCheck,

    /// <summary>
    /// StringValue0: module name.
    /// </summary>
    ModuleName,

    Output,

    /// <summary>
    /// IntValue0: profile
    /// </summary>
    Profile,

    /// <summary>
    /// IntValue0: stage
    /// </summary>
    Stage,

    /// <summary>
    /// IntValue0: CodeGenTarget
    /// </summary>
    Target,

    Version,

    /// <summary>
    /// StringValue0: "all" or comma separated list of warning codes or names.
    /// </summary>
    WarningsAsErrors,

    /// <summary>
    /// StringValue0: comma separated list of warning codes or names.
    /// </summary>
    DisableWarnings,

    /// <summary>
    /// StringValue0: warning code or name.
    /// </summary>
    EnableWarning,

    /// <summary>
    /// StringValue0: warning code or name.
    /// </summary>
    DisableWarning,

    DumpWarningDiagnostics,
    InputFilesRemain,

    /// <summary>
    /// bool
    /// </summary>
    EmitIr,

    /// <summary>
    /// bool
    /// </summary>
    ReportDownstreamTime,

    /// <summary>
    /// bool
    /// </summary>
    ReportPerfBenchmark,

    /// <summary>
    /// bool
    /// </summary>
    ReportCheckpointIntermediates,

    /// <summary>
    /// bool
    /// </summary>
    SkipSPIRVValidation,

    /// <summary>
    /// bool
    /// </summary>
    SourceEmbedStyle,

    SourceEmbedName,
    SourceEmbedLanguage,

    /// <summary>
    /// bool
    /// </summary>
    DisableShortCircuit,

    /// <summary>
    /// bool
    /// </summary>
    MinimumSlangOptimization,

    /// <summary>
    /// bool
    /// </summary>
    DisableNonEssentialValidations,

    /// <summary>
    /// bool
    /// </summary>
    DisableSourceMap,

    /// <summary>
    /// bool
    /// </summary>
    UnscopedEnum,

    /// <summary>
    /// bool: preserve all resource parameters in the output code.
    /// </summary>
    PreserveParameters,

    /// <summary>
    /// IntValue0: CapabilityName
    /// </summary>
    Capability,

    /// <summary>
    /// bool
    /// </summary>
    DefaultImageFormatUnknown,

    /// <summary>
    /// bool
    /// </summary>
    DisableDynamicDispatch,

    /// <summary>
    /// bool
    /// </summary>
    DisableSpecialization,

    /// <summary>
    /// IntValue0: FloatingPointMode
    /// </summary>
    FloatingPointMode,

    /// <summary>
    /// IntValue0: DebugInfoLevel
    /// </summary>
    DebugInformation,

    LineDirectiveMode,

    /// <summary>
    /// IntValue0: OptimizationLevel
    /// </summary>
    Optimization,

    /// <summary>
    /// bool
    /// </summary>
    Obfuscate,

    /// <summary>
    /// IntValue0 (higher 8 bits): kind; IntValue0(lower bits): set; IntValue1: shift
    /// </summary>
    VulkanBindShift,

    /// <summary>
    /// IntValue0: index; IntValue1: set
    /// </summary>
    VulkanBindGlobals,

    /// <summary>
    /// bool
    /// </summary>
    VulkanInvertY,

    /// <summary>
    /// bool
    /// </summary>
    VulkanUseDxPositionW,

    /// <summary>
    /// bool
    /// </summary>
    VulkanUseEntryPointName,

    /// <summary>
    /// bool
    /// </summary>
    VulkanUseGLLayout,

    /// <summary>
    /// bool
    /// </summary>
    VulkanEmitReflection,

    /// <summary>
    /// bool
    /// </summary>
    GLSLForceScalarLayout,

    /// <summary>
    /// bool
    /// </summary>
    EnableEffectAnnotations,

    /// <summary>
    /// bool (will be deprecated)
    /// </summary>
    EmitSpirvViaGLSL,

    /// <summary>
    /// bool (will be deprecated)
    /// </summary>
    EmitSpirvDirectly,

    /// <summary>
    /// StringValue0: json path
    /// </summary>
    SPIRVCoreGrammarJSON,

    /// <summary>
    /// bool, when set, will not issue an error when the linked program has unresolved extern function symbols.
    /// </summary>
    IncompleteLibrary,

    CompilerPath,
    DefaultDownstreamCompiler,

    /// <summary>
    /// StringValue0: downstream compiler name. StringValue1: argument list, one per line.
    /// </summary>
    DownstreamArgs,

    PassThrough,
    DumpRepro,
    DumpReproOnError,
    ExtractRepro,
    LoadRepro,
    LoadReproDirectory,
    ReproFallbackDirectory,
    DumpAst,
    DumpIntermediatePrefix,

    /// <summary>
    /// bool
    /// </summary>
    DumpIntermediates,

    /// <summary>
    /// bool
    /// </summary>
    DumpIr,

    DumpIrIds,
    PreprocessorOutput,
    OutputIncludes,
    ReproFileSystem,

    /// <summary>
    /// bool
    /// </summary>
    SerialIr,

    /// <summary>
    /// bool
    /// </summary>
    SkipCodeGen,

    /// <summary>
    /// bool
    /// </summary>
    ValidateIr,

    VerbosePaths,
    VerifyDebugSerialIr,

    /// <summary>
    /// Not used.
    /// </summary>
    NoCodeGen,

    // Experimental

    FileSystem,
    Heterogeneous,
    NoMangle,
    NoHLSLBinding,
    NoHLSLPackConstantBufferElements,
    ValidateUniformity,
    AllowGLSL,
    EnableExperimentalPasses,

    /// <summary>
    /// int
    /// </summary>
    BindlessSpaceIndex,

    ArchiveType,
    CompileCoreModule,
    Doc,
    IrCompression,
    LoadCoreModule,
    ReferenceModule,
    SaveCoreModule,
    SaveCoreModuleBinSource,
    TrackLiveness,

    /// <summary>
    /// bool, enable loop inversion optimization.
    /// </summary>
    LoopInversion,

    /// <summary>
    /// Deprecated.
    /// </summary>
    ParameterBlocksUseRegisterSpaces,

    CountOfParsableOptions,

    // Used in parsed options only.

    /// <summary>
    /// Used in parsed options only. <br/>
    /// IntValue0: DebugInfoFormat
    /// </summary>
    DebugInformationFormat,

    /// <summary>
    /// IntValue0: kind; IntValue1: shift
    /// </summary>
    VulkanBindShiftAll,

    /// <summary>
    /// bool
    /// </summary>
    GenerateWholeProgram,

    /// <summary>
    /// bool, when set, will only load precompiled modules if it is up-to-date with its source.
    /// </summary>
    UseUpToDateBinaryModule,

    /// <summary>
    /// bool
    /// </summary>
    EmbedDownstreamIR,

    /// <summary>
    /// bool
    /// </summary>
    ForceDXLayout,

    /// <summary>
    /// Add this new option to the end of the list to avoid breaking ABI as much as possible.
    /// Setting of EmitSpirvDirectly or EmitSpirvViaGLSL will turn into this option internally.
    /// </summary>
    EmitSpirvMethod,

    /// <summary>
    /// bool
    /// </summary>
    EmitReflectionJSON,

    SaveGLSLModuleBinSource,

    /// <summary>
    /// bool, experimental.
    /// </summary>
    SkipDownstreamLinking,

    DumpModule,

#pragma warning restore CS1591
}


/// <summary>
/// Type of value a compiler option holds.
/// </summary>
public enum CompilerOptionValueKind : int
{
    /// <summary>
    /// Integer value type.
    /// </summary>
    Int,

    /// <summary>
    /// String value type.
    /// </summary>
    String
}


/* Type that identifies how a path should be interpreted */
internal enum SlangPathType : uint
{
    Directory, // Path specified specifies a directory.
    File,      // Path specified is to a file.
}

/* Callback to enumerate the contents of of a directory in a ISlangFileSystemExt.
The name is the name of a file system object (directory/file) in the specified path (ie it is
without a path) */
// typedef void (
//         * FileSystemContentsCallBack) (SlangPathType pathType, byte* name, void* userData);

/* Determines how paths map to files on the OS file system */
internal enum OSPathKind : byte
{
    None,            /// Paths do not map to the file system
    Direct,          /// Paths map directly to the file system
    OperatingSystem, // Only paths gained via PathKind::OperatingSystem map to the operating
                     // system file system
}

/* Used to determine what kind of path is required from an input path */
internal enum PathKind : int
{
    /// Given a path, returns a simplified version of that path.
    /// This typically means removing '..' and/or '.' from the path.
    /// A simplified path must point to the same object as the original.
    Simplified,

    /// Given a path, returns a 'canonical path' to the item.
    /// This may be the operating system 'canonical path' that is the unique path to the item.
    ///
    /// If the item exists the returned canonical path should always be usable to access the
    /// item.
    ///
    /// If the item the path specifies doesn't exist, the canonical path may not be returnable
    /// or be a path simplification.
    /// Not all file systems support canonical paths.
    Canonical,

    /// Given a path returns a path such that it is suitable to be displayed to the user.
    ///
    /// For example if the file system is a zip file - it might include the path to the zip
    /// container as well as the path to the specific file.
    ///
    /// NOTE! The display path won't necessarily work on the file system to access the item
    Display,

    /// Get the path to the item on the *operating system* file system, if available.
    OperatingSystem,
}


/*

/// <summary>
/// Identifies different types of writer target
/// </summary>
public enum SlangWriterChannel : uint
{
    DIAGNOSTIC,
    STD_OUTPUT,
    STD_ERROR,
}

*/

/*

public enum SlangWriterMode : uint
{
    TEXT,
    BINARY,
};

*/


/*!
@brief Callback type used for diagnostic output.
*/
// typedef void (* SlangDiagnosticCallback) (byte* message, void* userData);


/// <summary>
/// Forward declarations of types used in the reflection interface.
/// </summary>
public enum GenericArgType : int
{
    /// <summary>
    /// A type that is not a generic argument, but rather a regular type.
    /// </summary>
    Type = 0,

    /// <summary>
    /// Integer argument type.
    /// </summary>
    Int = 1,

    /// <summary>
    /// Boolean argument type.
    /// </summary>
    Bool = 2
}


/// <summary>
/// The type kind of a shader type.
/// </summary>
public enum TypeKind : uint
{
#pragma warning disable CS1591
    None,
    Struct,
    Array,
    Matrix,
    Vector,
    Scalar,
    ConstantBuffer,
    Resource,
    SamplerState,
    TextureBuffer,
    ShaderStorageBuffer,
    ParameterBlock,
    GenericTypeParameter,
    Interface,
    OutputStream,
    MeshOutput,
    Specialized,
    Feedback,
    Pointer,
    DynamicResource
#pragma warning restore CS1591
}


/// <summary>
/// Scalar value types.
/// </summary>
public enum ScalarType : uint
{
#pragma warning disable CS1591
    None,
    Void,
    Bool,
    Int32,
    UInt32,
    Int64,
    UInt64,
    Float16,
    Float32,
    Float64,
    Int8,
    UInt8,
    Int16,
    UInt16,
    IntPtr,
    UIntPtr
#pragma warning restore CS1591
}


/// <summary>
/// The shape of a shader resource
/// </summary>
public enum ResourceShape : uint
{
#pragma warning disable CS1591
    BaseShapeMask = 0x0F,
    None = 0x00,

    Texture1D = 0x01,
    Texture2D = 0x02,
    Texture3D = 0x03,
    TextureCube = 0x04,
    TextureBuffer = 0x05,

    StructuredBuffer = 0x06,
    ByteAddressBuffer = 0x07,
    Unknown = 0x08,
    AccelerationStructure = 0x09,
    TextureSubpass = 0x0A,

    ExtShapeMask = 0xF0,

    TextureFeedbackFlag = 0x10,
    TextureShadowFlag = 0x20,
    TextureArrayFlag = 0x40,
    TextureMultisampleFlag = 0x80,

    SlangTexture1DArray = Texture1D | TextureArrayFlag,
    SlangTexture2DArray = Texture2D | TextureArrayFlag,
    SlangTextureCubeArray = TextureCube | TextureArrayFlag,

    SlangTexture2DMultisample = Texture2D | TextureMultisampleFlag,
    SlangTexture2DMultisampleArray = Texture2D | TextureMultisampleFlag | TextureArrayFlag,
    SlangTextureSubpassMultisample = TextureSubpass | TextureMultisampleFlag,
#pragma warning restore CS1591
}


/// <summary>
/// The resource access type of a shader uniform.
/// </summary>
public enum ResourceAccess : uint
{
#pragma warning disable CS1591
    None,
    Read,
    ReadWrite,
    RasterOrdered,
    Append,
    Consume,
    Write,
    Feedback,
    Unknown = 0x7FFFFFFF,
#pragma warning restore CS1591
}


/// <summary>
/// The category of a parameter in a shader.
/// </summary>
public enum ParameterCategory : uint
{
#pragma warning disable CS1591
    None,
    Mixed,
    ConstantBuffer,
    ShaderResource,
    UnorderedAccess,
    VaryingInput,
    VaryingOutput,
    SamplerState,
    Uniform,
    DescriptorTableSlot,
    SpecializationConstant,
    PushConstantBuffer,

    /// <summary>
    /// HLSL register `space`, Vulkan GLSL `set`
    /// </summary>
    RegisterSpace,

    /// <summary>
    /// A parameter whose type is to be specialized by a global generic type argument.
    /// </summary>
    Generic,

    RayPayload,
    HitAttributes,
    CallablePayload,
    ShaderRecord,

    /// <summary>
    /// <para>
    /// An existential type parameter represents a "hole" that
    /// needs to be filled with a concrete type to enable
    /// generation of specialized code.
    /// </para>
    /// <para>
    /// Consider this example:
    /// </para>
    /// <code>
    /// struct MyParams
    /// {
    ///     IMaterial material;
    ///     ILight lights[3];
    /// };
    /// </code>
    /// <para>
    /// This `MyParams` type introduces two existential type parameters:
    /// one for `material` and one for `lights`. Even though `lights`
    /// is an array, it only introduces one type parameter, because
    /// we need to have a *single* concrete type for all the array
    /// elements to be able to generate specialized code.
    /// </para>
    /// </summary>
    ExistentialTypeParam,

    /// <summary>
    /// <para>
    /// An existential object parameter represents a value
    /// that needs to be passed in to provide data for some
    /// interface-type shader parameter.
    /// </para>
    /// <para>
    /// Consider this example:
    /// </para>
    /// <code>
    /// struct MyParams
    /// {
    ///     IMaterial material;
    ///     ILight lights[3];
    /// };
    /// </code>
    /// <para>
    /// This `MyParams` type introduces four existential object parameters:
    /// one for `material` and three for `lights` (one for each array
    /// element). This is consistent with the number of interface-type
    /// "objects" that are being passed through to the shader.
    /// </para>
    /// </summary>
    ExistentialObjectParam,

    /// <summary>
    /// The register space offset for the sub-elements that occupies register spaces.
    /// </summary>
    SubElementRegisterSpace,

    /// <summary>
    /// The input_attachment_index subpass occupancy tracker.
    /// </summary>
    Subpass,

    /// <summary>
    /// Metal tier-1 argument buffer element [[id]].
    /// </summary>
    MetalArgumentBufferElement,

    /// <summary>
    /// Metal [[attribute]] inputs.
    /// </summary>
    MetalAttribute,

    /// <summary>
    /// Metal [[payload]] inputs.
    /// </summary>
    MetalPayload,
#pragma warning restore CS1591
}

/// <summary>
/// <para>
/// Types of API-managed bindings that a parameter might use.
/// </para>
/// <para>
/// `BindingType` represents the distinct types of binding ranges that might be
/// understood by an underlying graphics API or cross-API abstraction layer.
/// Several of the enumeration cases here correspond to cases of `VkDescriptorType`
/// defined by the Vulkan API. Note however that the values of this enumeration
/// are not the same as those of any particular API.
/// </para>
/// <para>
/// The `BindingType` enumeration is distinct from `ParameterCategory`
/// because `ParameterCategory` differentiates the types of parameters for
/// the purposes of layout, where the layout rules of some targets will treat
/// parameters of different types as occupying the same binding space for layout
/// (e.g., in SPIR-V both a `Texture2D` and `SamplerState` use the same space of
/// `binding` indices, and are not allowed to overlap), while those same types
/// map to different types of bindings in the API (e.g., both textures and samplers
/// use different `VkDescriptorType` values).
/// </para>
/// <para>
/// When you want to answer "what register/binding did this parameter use?" you
/// should use `ParameterCategory`.
/// </para>
/// <para>
/// When you want to answer "what type of descriptor range should this parameter use?"
/// you should use `BindingType`.
/// </para>
/// </summary>
public enum BindingType : uint
{
    /// <summary>
    /// Unknown binding type.
    /// </summary>
    Unknown = 0,

    /// <summary>
    /// Sampler binding type.
    /// </summary>
    Sampler,

    /// <summary>
    /// Texture binding type.
    /// </summary>
    Texture,

    /// <summary>
    /// Constant buffer binding type.
    /// </summary>
    ConstantBuffer,

    /// <summary>
    /// Parameter block binding type.
    /// </summary>
    ParameterBlock,

    /// <summary>
    /// Typed buffer binding type.
    /// </summary>
    TypedBuffer,

    /// <summary>
    /// Raw buffer binding type.
    /// </summary>
    RawBuffer,

    /// <summary>
    /// Combined texture-sampler binding type.
    /// </summary>
    CombinedTextureSampler,

    /// <summary>
    /// Input render target binding type.
    /// </summary>
    InputRenderTarget,

    /// <summary>
    /// Inline uniform data binding type.
    /// </summary>
    InlineUniformData,

    /// <summary>
    /// RT acceleration structure binding type.
    /// </summary>
    RayTracingAccelerationStructure,

    /// <summary>
    /// Varying input binding type.
    /// </summary>
    VaryingInput,

    /// <summary>
    /// Varying output binding type.
    /// </summary>
    VaryingOutput,

    /// <summary>
    /// Existential value binding type.
    /// </summary>
    ExistentialValue,

    /// <summary>
    /// Push constant binding type.
    /// </summary>
    PushConstant,

    // MUTABLE_FLAG = 0x100,

    /// <summary>
    /// A mutable (read/write) texture binding type.
    /// </summary>
    MutableTexture = Texture | 0x100,

    /// <summary>
    /// A mutable (read/write) typed buffer binding type.
    /// </summary>
    MutableTypedBuffer = TypedBuffer | 0x100,

    /// <summary>
    /// A mutable (read/write) raw buffer binding type.
    /// </summary>
    MutableRawBuffer = RawBuffer | 0x100,

#pragma warning disable CS1591
    BaseMask = 0x00FF,
    ExtMask = 0xFF00,
#pragma warning restore CS1591
}


/// <summary>
/// The type of memory layout used by a shader for a type.
/// </summary>
public enum LayoutRules : uint
{
    /// <summary>
    /// Default layout.
    /// </summary>
    Default,

    /// <summary>
    /// Tier 2 MTL arguments buffer.
    /// </summary>
    MetalArgumentBufferTier2,
}


/// <summary>
/// The possible image formats of a shader uniform.
/// </summary>
public enum ImageFormat : uint
{
#pragma warning disable CS1591
    Unknown,
    RGBA32Float,
    RGBA16Float,
    RG32Float,
    RG16Float,
    R11Float_G11Float_b10Float,
    R32Float,
    R16Float,
    RGBA16,
    RGB10_A2,
    RGBA8,
    RG16,
    RG8,
    R16,
    R8,
    RGBA16_SNorm,
    RGBA8_SNorm,
    RG16_SNorm,
    RG8_SNorm,
    R16_SNorm,
    R8_SNorm,
    RGBA32Int,
    RGBA16Int,
    RGBA8Int,
    RG32Int,
    RG16Int,
    RG8Int,
    R32Int,
    R16Int,
    R8Int,
    RGBA32UInt,
    RGBA16UInt,
    RGB10_A2UInt,
    RGBA8UInt,
    RG32UInt,
    RG16UInt,
    RG8UInt,
    R32UInt,
    R16UInt,
    R8UInt,
    R64UInt,
    R64Int,
    BGRA8,
#pragma warning restore CS1591
}


internal enum CompileCoreModuleFlags : uint
{
    WriteDocumentation = 0x1,
}


internal enum BuiltinModuleName : int
{
    Core,
    GLSL
}


/// <summary>
/// The container type of a shader variable.
/// </summary>
public enum ContainerType : int
{
    /// <summary>
    /// Variable is not a container.
    /// </summary>
    None,

    /// <summary>
    /// Container is an unsized array.
    /// </summary>
    UnsizedArray,

    /// <summary>
    /// Container is a structured buffer.
    /// </summary>
    StructuredBuffer,

    /// <summary>
    /// Container is a constant buffer.
    /// </summary>
    ConstantBuffer,

    /// <summary>
    /// Container is a parameter block.
    /// </summary>
    ParameterBlock
}


/// <summary>
/// Passed into functions to create globalSession to identify the API version client code is
/// using.
/// </summary>
public enum LanguageVersion : uint
{
    /// <summary>
    /// Language version 2025
    /// </summary>
    _2025 = 2025
}

/// <summary>
/// Flags used when creating a <see cref="Session"/> instance.
/// </summary>
public enum SessionFlags : uint
{
    ///
    None = 0
}
