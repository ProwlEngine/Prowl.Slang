using System;
using System.Runtime.InteropServices;

using SlangUInt32 = uint;
using SlangInt32 = int;

using SlangInt = nint;
using SlangUInt = nuint;

using SlangBool = bool;

namespace Prowl.Slang.Native;

/*!
@brief Severity of a diagnostic generated by the compiler.
Values come from the enum below, with higher values representing more severe
conditions, and all values >= SLANG_SEVERITY_ERROR indicating compilation
failure.
*/
public enum SlangSeverity : int
{
    Disabled = 0, /**< A message that is disabled, filtered out. */
    Note,         /**< An informative message. */
    Warning,      /**< A warning, which indicates a possible problem. */
    Error,        /**< An error, indicating that compilation failed. */
    Fatal,    /**< An unrecoverable error, which forced compilation to abort. */
    Internal, /**< An internal error, indicating a logic error in the compiler.
                                  */
}


[Flags]
public enum SlangDiagnosticFlags : int
{
    VerbosePaths = 0x01,
    TreatWarningsAsErrors = 0x02
}


public enum SlangBindableResourceType : int
{
    NonBindable = 0,
    Texture,
    Sampler,
    UniformBuffer,
    StorageBuffer,
}


/* NOTE! To keep binary compatibility care is needed with this enum!

* To add value, only add at the bottom (before COUNT_OF)
* To remove a value, add _DEPRECATED as a suffix, but leave in the list

This will make the enum values stable, and compatible with libraries that might not use the
latest enum values.
*/
public enum SlangCompileTarget : int
{
    TARGET_UNKNOWN,
    TARGET_NONE,
    GLSL,
    GLSL_VULKAN_DEPRECATED,          //< deprecated and removed: just use `SLANG_GLSL`.
    GLSL_VULKAN_ONE_DESC_DEPRECATED, //< deprecated and removed.
    HLSL,
    SPIRV,
    SPIRV_ASM,
    DXBC,
    DXBC_ASM,
    DXIL,
    DXIL_ASM,
    C_SOURCE,              ///< The C language
    CPP_SOURCE,            ///< C++ code for shader kernels.
    HOST_EXECUTABLE,       ///< Standalone binary executable (for hosting CPU/OS)
    SHADER_SHARED_LIBRARY, ///< A shared library/Dll for shader kernels (for hosting
                           ///< CPU/OS)
    SHADER_HOST_CALLABLE,  ///< A CPU target that makes the compiled shader code available
                           ///< to be run immediately
    CUDA_SOURCE,           ///< Cuda source
    PTX,                   ///< PTX
    CUDA_OBJECT_CODE,      ///< Object code that contains CUDA functions.
    OBJECT_CODE,           ///< Object code that can be used for later linking
    HOST_CPP_SOURCE,       ///< C++ code for host library or executable.
    HOST_HOST_CALLABLE,    ///< Host callable host code (ie non kernel/shader)
    CPP_PYTORCH_BINDING,   ///< C++ PyTorch binding code.
    METAL,                 ///< Metal shading language
    METAL_LIB,             ///< Metal library
    METAL_LIB_ASM,         ///< Metal library assembly
    HOST_SHARED_LIBRARY,   ///< A shared library/Dll for host code (for hosting CPU/OS)
    WGSL,                  ///< WebGPU shading language
    WGSL_SPIRV_ASM,        ///< SPIR-V assembly via WebGPU shading language
    WGSL_SPIRV,            ///< SPIR-V via WebGPU shading language
}


/* A "container format" describes the way that the outputs
for multiple files, entry points, targets, etc. should be
combined into a single artifact for output. */
public enum SlangContainerFormat : int
{
    /* Don't generate a container. */
    NONE,

    /* Generate a container in the `.slang-module` format,
    which includes reflection information, compiled kernels, etc. */
    SLANG_MODULE,
}


public enum SlangPassThrough : int
{
    NONE,
    FXC,
    DXC,
    GLSLANG,
    SPIRV_DIS,
    CLANG,         ///< Clang C/C++ compiler
    VISUAL_STUDIO, ///< Visual studio C/C++ compiler
    GCC,           ///< GCC C/C++ compiler
    GENERIC_C_CPP, ///< Generic C or C++ compiler, which is decided by the
                   ///< source type
    NVRTC,         ///< NVRTC Cuda compiler
    LLVM,          ///< LLVM 'compiler' - includes LLVM and Clang
    SPIRV_OPT,     ///< SPIRV-opt
    METAL,         ///< Metal compiler
    TINT,          ///< Tint WGSL compiler
    SPIRV_LINK,    ///< SPIRV-link
}


/* Defines an archive type used to holds a 'file system' type structure. */
public enum SlangArchiveType : int
{
    UNDEFINED,
    ZIP,
    RIFF, ///< Riff container with no compression
    RIFF_DEFLATE,
    RIFF_LZ4,
}


/*!
Flags to control compilation behavior.
*/
[Flags]
public enum SlangCompileFlags : uint
{
    /* Do as little mangling of names as possible, to try to preserve original names */
    NO_MANGLING = 1 << 3,

    /* Skip code generation step, just check the code and generate layout */
    NO_CODEGEN = 1 << 4,

    /* Obfuscate shader names on release products */
    OBFUSCATE = 1 << 5,

    /* Deprecated flags: kept around to allow existing applications to
    compile. Note that the relevant features will still be left in
    their default state. */
    NO_CHECKING = 0,
    SPLIT_MIXED_TYPES = 0,
}


/*!
@brief Flags to control code generation behavior of a compilation target */
[Flags]
public enum SlangTargetFlags : uint
{
    /* When compiling for a D3D Shader Model 5.1 or higher target, allocate
       distinct register spaces for parameter blocks.

       @deprecated This behavior is now enabled unconditionally.
    */
    PARAMETER_BLOCKS_USE_REGISTER_SPACES = 1 << 4,

    /* When set, will generate target code that contains all entrypoints defined
       in the input source or specified via the `spAddEntryPoint` function in a
       single output module (library/source file).
    */
    GENERATE_WHOLE_PROGRAM = 1 << 8,

    /* When set, will dump out the IR between intermediate compilation steps.*/
    DUMP_IR = 1 << 9,

    /* When set, will generate SPIRV directly rather than via glslang. */
    // This flag will be deprecated, use CompilerOption instead.
    GENERATE_SPIRV_DIRECTLY = 1 << 10,

    Default = GENERATE_SPIRV_DIRECTLY
}


/*!
@brief Options to control floating-point precision guarantees for a target.
*/
public enum SlangFloatingPointMode : uint
{
    DEFAULT = 0,
    FAST,
    PRECISE,
}


/*!
@brief Options to control emission of `#line` directives
*/
public enum SlangLineDirectiveMode : uint
{
    DEFAULT =
        0,                              /**< Default behavior: pick behavior base on target. */
    NONE,     /**< Don't emit line directives at all. */
    STANDARD, /**< Emit standard C-style `#line` directives. */
    GLSL, /**< Emit GLSL-style directives with file *number* instead
                                           of name */
    SOURCE_MAP, /**< Use a source map to track line mappings (ie no
                                                 #line will appear in emitting source) */
}


public enum SlangSourceLanguage : int
{
    UNKNOWN,
    SLANG,
    HLSL,
    GLSL,
    C,
    CPP,
    CUDA,
    SPIRV,
    METAL,
    WGSL,
}


public enum SlangProfileID : uint
{
    UNKNOWN,
}


public enum SlangCapabilityID : SlangInt32
{
    UNKNOWN = 0,
}


public enum SlangMatrixLayoutMode : uint
{
    MODE_UNKNOWN = 0,
    ROW_MAJOR,
    COLUMN_MAJOR,
}


public enum SlangStage : SlangUInt32
{
    NONE,
    VERTEX,
    HULL,
    DOMAIN,
    GEOMETRY,
    FRAGMENT,
    COMPUTE,
    RAY_GENERATION,
    INTERSECTION,
    ANY_HIT,
    CLOSEST_HIT,
    MISS,
    CALLABLE,
    MESH,
    AMPLIFICATION
}


public enum SlangDebugInfoLevel : SlangUInt32
{
    NONE = 0, /**< Don't emit debug information at all. */
    MINIMAL,  /**< Emit as little debug information as possible, while
                                            still supporting stack trackers. */
    STANDARD, /**< Emit whatever is the standard level of debug
                                            information for each target. */
    MAXIMAL,  /**< Emit as much debug information as possible for each
                                            target. */
}


/* Describes the debugging information format produced during a compilation. */
public enum SlangDebugInfoFormat : SlangUInt32
{
    DEFAULT, ///< Use the default debugging format for the target
    C7,  ///< CodeView C7 format (typically means debugging information
         ///< is embedded in the binary)
    PDB, ///< Program database

    STABS, ///< Stabs
    COFF,  ///< COFF debug info
    DWARF, ///< DWARF debug info (we may want to support specifying the
           ///< version)
}


public enum SlangOptimizationLevel : SlangUInt32
{
    NONE = 0, /**< Don't optimize at all. */
    DEFAULT,  /**< Default optimization level: balance code quality and
                                              compilation time. */
    HIGH,     /**< Optimize aggressively. */
    MAXIMAL, /**< Include optimizations that may take a very long time,
                                             or may involve severe space-vs-speed tradeoffs */
}


public enum SlangEmitSpirvMethod : int
{
    DEFAULT = 0,
    VIA_GLSL,
    DIRECTLY,
}


public enum CompilerOptionName : int
{
    MacroDefine, // stringValue0: macro name;  stringValue1: macro value
    DepFile,
    EntryPointName,
    Specialize,
    Help,
    HelpStyle,
    Include, // stringValue: additional include path.
    Language,
    MatrixLayoutColumn,         // bool
    MatrixLayoutRow,            // bool
    ZeroInitialize,             // bool
    IgnoreCapabilities,         // bool
    RestrictiveCapabilityCheck, // bool
    ModuleName,                 // stringValue0: module name.
    Output,
    Profile, // intValue0: profile
    Stage,   // intValue0: stage
    Target,  // intValue0: CodeGenTarget
    Version,
    WarningsAsErrors, // stringValue0: "all" or comma separated list of warning codes or names.
    DisableWarnings,  // stringValue0: comma separated list of warning codes or names.
    EnableWarning,    // stringValue0: warning code or name.
    DisableWarning,   // stringValue0: warning code or name.
    DumpWarningDiagnostics,
    InputFilesRemain,
    EmitIr,                        // bool
    ReportDownstreamTime,          // bool
    ReportPerfBenchmark,           // bool
    ReportCheckpointIntermediates, // bool
    SkipSPIRVValidation,           // bool
    SourceEmbedStyle,
    SourceEmbedName,
    SourceEmbedLanguage,
    DisableShortCircuit,            // bool
    MinimumSlangOptimization,       // bool
    DisableNonEssentialValidations, // bool
    DisableSourceMap,               // bool
    UnscopedEnum,                   // bool
    PreserveParameters, // bool: preserve all resource parameters in the output code.

    // Target

    Capability,                // intValue0: CapabilityName
    DefaultImageFormatUnknown, // bool
    DisableDynamicDispatch,    // bool
    DisableSpecialization,     // bool
    FloatingPointMode,         // intValue0: FloatingPointMode
    DebugInformation,          // intValue0: DebugInfoLevel
    LineDirectiveMode,
    Optimization, // intValue0: OptimizationLevel
    Obfuscate,    // bool

    VulkanBindShift, // intValue0 (higher 8 bits): kind; intValue0(lower bits): set; intValue1:
                     // shift
    VulkanBindGlobals,       // intValue0: index; intValue1: set
    VulkanInvertY,           // bool
    VulkanUseDxPositionW,    // bool
    VulkanUseEntryPointName, // bool
    VulkanUseGLLayout,       // bool
    VulkanEmitReflection,    // bool

    GLSLForceScalarLayout,   // bool
    EnableEffectAnnotations, // bool

    EmitSpirvViaGLSL,     // bool (will be deprecated)
    EmitSpirvDirectly,    // bool (will be deprecated)
    SPIRVCoreGrammarJSON, // stringValue0: json path
    IncompleteLibrary,    // bool, when set, will not issue an error when the linked program has
                          // unresolved extern function symbols.

    // Downstream

    CompilerPath,
    DefaultDownstreamCompiler,
    DownstreamArgs, // stringValue0: downstream compiler name. stringValue1: argument list, one
                    // per line.
    PassThrough,

    // Repro

    DumpRepro,
    DumpReproOnError,
    ExtractRepro,
    LoadRepro,
    LoadReproDirectory,
    ReproFallbackDirectory,

    // Debugging

    DumpAst,
    DumpIntermediatePrefix,
    DumpIntermediates, // bool
    DumpIr,            // bool
    DumpIrIds,
    PreprocessorOutput,
    OutputIncludes,
    ReproFileSystem,
    SerialIr,    // bool
    SkipCodeGen, // bool
    ValidateIr,  // bool
    VerbosePaths,
    VerifyDebugSerialIr,
    NoCodeGen, // Not used.

    // Experimental

    FileSystem,
    Heterogeneous,
    NoMangle,
    NoHLSLBinding,
    NoHLSLPackConstantBufferElements,
    ValidateUniformity,
    AllowGLSL,
    EnableExperimentalPasses,
    BindlessSpaceIndex, // int

    // Internal

    ArchiveType,
    CompileCoreModule,
    Doc,
    IrCompression,
    LoadCoreModule,
    ReferenceModule,
    SaveCoreModule,
    SaveCoreModuleBinSource,
    TrackLiveness,
    LoopInversion, // bool, enable loop inversion optimization

    // Deprecated
    ParameterBlocksUseRegisterSpaces,

    CountOfParsableOptions,

    // Used in parsed options only.
    DebugInformationFormat,  // intValue0: DebugInfoFormat
    VulkanBindShiftAll,      // intValue0: kind; intValue1: shift
    GenerateWholeProgram,    // bool
    UseUpToDateBinaryModule, // bool, when set, will only load
                             // precompiled modules if it is up-to-date with its source.
    EmbedDownstreamIR,       // bool
    ForceDXLayout,           // bool

    // Add this new option to the end of the list to avoid breaking ABI as much as possible.
    // Setting of EmitSpirvDirectly or EmitSpirvViaGLSL will turn into this option internally.
    EmitSpirvMethod, // enum SlangEmitSpirvMethod

    EmitReflectionJSON, // bool
    SaveGLSLModuleBinSource,

    SkipDownstreamLinking, // bool, experimental
    DumpModule,
    CountOf,
}


public enum CompilerOptionValueKind : int
{
    Int,
    String
}


[StructLayout(LayoutKind.Sequential)]
public unsafe struct CompilerOptionValue()
{
    public CompilerOptionValueKind kind = CompilerOptionValueKind.Int;
    public int intValue0 = 0;
    public int intValue1 = 0;
    public byte* stringValue0 = null;
    public byte* stringValue1 = null;
}


[StructLayout(LayoutKind.Sequential)]
public struct CompilerOptionEntry
{
    CompilerOptionName name;
    CompilerOptionValue value;
}


/* An interface to provide a mechanism to cast, that doesn't require ref counting
and doesn't have to return a pointer to a IUnknown derived class */
[UUID(0x87ede0e1, 0x4852, 0x44b0, 0x8b, 0xf2, 0xcb, 0x31, 0x87, 0x4d, 0xe2, 0x39)]
public unsafe interface ISlangCastable : IUnknown
{
    /// Can be used to cast to interfaces without reference counting.
    /// Also provides access to internal implementations, when they provide a guid
    /// Can simulate a 'generated' interface as long as kept in scope by cast from.
    void* CastAs(in Guid guid);
}


[UUID(0x1ec36168, 0xe9f4, 0x430d, 0xbb, 0x17, 0x4, 0x8a, 0x80, 0x46, 0xb3, 0x1f)]
public unsafe interface ISlangClonable : ISlangCastable
{
    /// Note the use of guid is for the desired interface/object.
    /// The object is returned *not* ref counted. Any type that can implements the interface,
    /// derives from ICastable, and so (not withstanding some other issue) will always return
    /// an ICastable interface which other interfaces/types are accessible from via castAs
    void* Clone(in Guid guid);
}


/** A "blob" of binary data.

This interface definition is compatible with the `ID3DBlob` and `ID3D10Blob` interfaces.
*/
[UUID(0x8BA5FB08, 0x5195, 0x40e2, 0xAC, 0x58, 0x0D, 0x98, 0x9C, 0x3A, 0x01, 0x02)]
public unsafe interface ISlangBlob : IUnknown
{
    void* GetBufferPointer();
    nuint GetBufferSize();
}


/* Can be requested from ISlangCastable cast to indicate the contained chars are null
 * terminated.
 */
[UUID(0xbe0db1a8, 0x3594, 0x4603, 0xa7, 0x8b, 0xc4, 0x86, 0x84, 0x30, 0xdf, 0xbb)]
interface SlangTerminatedChars
{
    //      operator byte*() const { return chars; }
    //      char chars[1];
};

/** A (real or virtual) file system.

Slang can make use of this interface whenever it would otherwise try to load files
from disk, allowing applications to hook and/or override filesystem access from
the compiler.

It is the responsibility of
the caller of any method that returns a ISlangBlob to release the blob when it is no
longer used (using 'release').
*/

[UUID(0x003A09FC, 0x3A4D, 0x4BA0, 0xAD, 0x60, 0x1F, 0xD8, 0x63, 0xA9, 0x15, 0xAB)]
public unsafe interface ISlangFileSystem : ISlangCastable
{
    /** Load a file from `path` and return a blob of its contents
    @param path The path to load from, as a null-terminated UTF-8 string.
    @param outBlob A destination pointer to receive the blob of the file contents.
    @returns A `SlangResult` to indicate success or failure in loading the file.

    NOTE! This is a *binary* load - the blob should contain the exact same bytes
    as are found in the backing file.

    If load is successful, the implementation should create a blob to hold
    the file's content, store it to `outBlob`, and return 0.
    If the load fails, the implementation should return a failure status
    (any negative value will do).
    */
    SlangResult LoadFile(byte* path, out ISlangBlob* outBlob);
}


// typedef void (* SlangFuncPtr) (void);

/**
(DEPRECATED) ISlangSharedLibrary
*/
[UUID(0x9c9d5bc5, 0xeb61, 0x496f, 0x80, 0xd7, 0xd1, 0x47, 0xc4, 0xa2, 0x37, 0x30)]
public unsafe interface ISlangSharedLibrary_Dep1 : IUnknown
{
    void* FindSymbolAddressByName(byte* name);
}

/** An interface that can be used to encapsulate access to a shared library. An implementation
does not have to implement the library as a shared library
*/
[UUID(0x70dbc7c4, 0xdc3b, 0x4a07, 0xae, 0x7e, 0x75, 0x2a, 0xf6, 0xa8, 0x15, 0x55)]
public unsafe interface ISlangSharedLibrary : ISlangCastable
{
    /** Get a symbol by name. If the library is unloaded will only return null.
    @param name The name of the symbol
    @return The pointer related to the name or null if not found
    */
    void* FindSymbolAddressByName(byte* name);
}


[UUID(0x6264ab2b, 0xa3e8, 0x4a06, 0x97, 0xf1, 0x49, 0xbc, 0x2d, 0x2a, 0xb1, 0x4d)]
public unsafe interface ISlangSharedLibraryLoader : IUnknown
{
    /** Load a shared library. In typical usage the library name should *not* contain any
    platform specific elements. For example on windows a dll name should *not* be passed with a
    '.dll' extension, and similarly on linux a shared library should *not* be passed with the
    'lib' prefix and '.so' extension
    @path path The unadorned filename and/or path for the shared library
    @ param sharedLibraryOut Holds the shared library if successfully loaded */
    SlangResult LoadSharedLibrary(byte* path, out ISlangSharedLibrary* sharedLibraryOut);
}


/* Type that identifies how a path should be interpreted */
public enum SlangPathType : uint
{
    DIRECTORY, /**< Path specified specifies a directory. */
    FILE,      /**< Path specified is to a file. */
};

/* Callback to enumerate the contents of of a directory in a ISlangFileSystemExt.
The name is the name of a file system object (directory/file) in the specified path (ie it is
without a path) */
// typedef void (
//         * FileSystemContentsCallBack) (SlangPathType pathType, byte* name, void* userData);

/* Determines how paths map to files on the OS file system */
public enum OSPathKind : byte
{
    None,            ///< Paths do not map to the file system
    Direct,          ///< Paths map directly to the file system
    OperatingSystem, ///< Only paths gained via PathKind::OperatingSystem map to the operating
                     ///< system file system
};

/* Used to determine what kind of path is required from an input path */
public enum PathKind : int
{
    /// Given a path, returns a simplified version of that path.
    /// This typically means removing '..' and/or '.' from the path.
    /// A simplified path must point to the same object as the original.
    Simplified,

    /// Given a path, returns a 'canonical path' to the item.
    /// This may be the operating system 'canonical path' that is the unique path to the item.
    ///
    /// If the item exists the returned canonical path should always be usable to access the
    /// item.
    ///
    /// If the item the path specifies doesn't exist, the canonical path may not be returnable
    /// or be a path simplification.
    /// Not all file systems support canonical paths.
    Canonical,

    /// Given a path returns a path such that it is suitable to be displayed to the user.
    ///
    /// For example if the file system is a zip file - it might include the path to the zip
    /// container as well as the path to the specific file.
    ///
    /// NOTE! The display path won't necessarily work on the file system to access the item
    Display,

    /// Get the path to the item on the *operating system* file system, if available.
    OperatingSystem,
}


/** An extended file system abstraction.

Implementing and using this interface over ISlangFileSystem gives much more control over how
paths are managed, as well as how it is determined if two files 'are the same'.

All paths as input byte*, or output as ISlangBlobs are always encoded as UTF-8 strings.
Blobs that contain strings are always zero terminated.
*/
[UUID(0x5fb632d2, 0x979d, 0x4481, 0x9f, 0xee, 0x66, 0x3c, 0x3f, 0x14, 0x49, 0xe1)]
public unsafe interface ISlangFileSystemExt : ISlangFileSystem
{
    /** Get a uniqueIdentity which uniquely identifies an object of the file system.

    Given a path, returns a 'uniqueIdentity' which ideally is the same value for the same object
    on the file system.

    The uniqueIdentity is used to compare if two paths are the same - which amongst other things
    allows Slang to cache source contents internally. It is also used for #pragma once
    functionality.

    A *requirement* is for any implementation is that two paths can only return the same
    uniqueIdentity if the contents of the two files are *identical*. If an implementation breaks
    this constraint it can produce incorrect compilation. If an implementation cannot *strictly*
    identify *the same* files, this will only have an effect on #pragma once behavior.

    The string for the uniqueIdentity is held zero terminated in the ISlangBlob of
    outUniqueIdentity.

    Note that there are many ways a uniqueIdentity may be generated for a file. For example it
    could be the 'canonical path' - assuming it is available and unambiguous for a file system.
    Another possible mechanism could be to store the filename combined with the file date time
    to uniquely identify it.

    The client must ensure the blob be released when no longer used, otherwise memory will leak.

    NOTE! Ideally this method would be called 'getPathUniqueIdentity' but for historical reasons
    and backward compatibility it's name remains with 'File' even though an implementation
    should be made to work with directories too.

    @param path
    @param outUniqueIdentity
    @returns A `SlangResult` to indicate success or failure getting the uniqueIdentity.
    */
    SlangResult GetFileUniqueIdentity(byte* path, out ISlangBlob* outUniqueIdentity);

    /** Calculate a path combining the 'fromPath' with 'path'

    The client must ensure the blob be released when no longer used, otherwise memory will leak.

    @param fromPathType How to interpret the from path - as a file or a directory.
    @param fromPath The from path.
    @param path Path to be determined relative to the fromPath
    @param pathOut Holds the string which is the relative path. The string is held in the blob
    zero terminated.
    @returns A `SlangResult` to indicate success or failure in loading the file.
    */
    SlangResult CalcCombinedPath(SlangPathType fromPathType, byte* fromPath, byte* path, out ISlangBlob* pathOut);

    /** Gets the type of path that path is on the file system.
    @param path
    @param pathTypeOut
    @returns SLANG_OK if located and type is known, else an error. SLANG_E_NOT_FOUND if not
    found.
    */
    SlangResult GetPathType(byte* path, out SlangPathType pathTypeOut);

    /** Get a path based on the kind.

    @param kind The kind of path wanted
    @param path The input path
    @param outPath The output path held in a blob
    @returns SLANG_OK if successfully simplified the path (SLANG_E_NOT_IMPLEMENTED if not
    implemented, or some other error code)
    */
    SlangResult GetPath(PathKind kind, byte* path, out ISlangBlob* outPath);

    /** Clears any cached information */
    void ClearCache();

    /** Enumerate the contents of the path

    Note that for normal Slang operation it isn't necessary to enumerate contents this can
    return SLANG_E_NOT_IMPLEMENTED.

    @param The path to enumerate
    @param callback This callback is called for each entry in the path.
    @param userData This is passed to the callback
    @returns SLANG_OK if successful
    */
    SlangResult EnumeratePathContents(byte* path, void* callback, void* userData);

    /** Returns how paths map to the OS file system

    @returns OSPathKind that describes how paths map to the Operating System file system
    */
    OSPathKind GetOSPathKind();
}


[UUID(0xa058675c, 0x1d65, 0x452a, 0x84, 0x58, 0xcc, 0xde, 0xd1, 0x42, 0x71, 0x5)]
public unsafe interface ISlangMutableFileSystem : ISlangFileSystemExt
{
    /** Write data to the specified path.

    @param path The path for data to be saved to
    @param data The data to be saved
    @param size The size of the data in bytes
    @returns SLANG_OK if successful (SLANG_E_NOT_IMPLEMENTED if not implemented, or some other
    error code)
    */
    SlangResult SaveFile(byte* path, void* data, nuint size);

    /** Write data in the form of a blob to the specified path.

    Depending on the implementation writing a blob might be faster/use less memory. It is
    assumed the blob is *immutable* and that an implementation can reference count it.

    It is not guaranteed loading the same file will return the *same* blob - just a blob with
    same contents.

    @param path The path for data to be saved to
    @param dataBlob The data to be saved
    @returns SLANG_OK if successful (SLANG_E_NOT_IMPLEMENTED if not implemented, or some other
    error code)
    */
    SlangResult SaveFileBlob(byte* path, ISlangBlob* dataBlob);

    /** Remove the entry in the path (directory of file). Will only delete an empty directory,
    if not empty will return an error.

    @param path The path to remove
    @returns SLANG_OK if successful
    */
    SlangResult Remove(byte* path);

    /** Create a directory.

    The path to the directory must exist

    @param path To the directory to create. The parent path *must* exist otherwise will return
    an error.
    @returns SLANG_OK if successful
    */
    SlangResult CreateDirectory(byte* path);
}


/* Identifies different types of writer target*/
public enum SlangWriterChannel : uint
{
    DIAGNOSTIC,
    STD_OUTPUT,
    STD_ERROR,
};


public enum SlangWriterMode : uint
{
    TEXT,
    BINARY,
};


/** A stream typically of text, used for outputting diagnostic as well as other information.
 */
[UUID(0xec457f0e, 0x9add, 0x4e6b, 0x85, 0x1c, 0xd7, 0xfa, 0x71, 0x6d, 0x15, 0xfd)]
public unsafe interface ISlangWriter : IUnknown
{
    /** Begin an append buffer.
    NOTE! Only one append buffer can be active at any time.
    @param maxNumChars The maximum of chars that will be appended
    @returns The start of the buffer for appending to. */
    byte* BeginAppendBuffer(nuint maxNumChars);

    /** Ends the append buffer, and is equivalent to a write of the append buffer.
    NOTE! That an endAppendBuffer is not necessary if there are no characters to write.
    @param buffer is the start of the data to append and must be identical to last value
    returned from beginAppendBuffer
    @param numChars must be a value less than or equal to what was returned from last call to
    beginAppendBuffer
    @returns Result, will be SLANG_OK on success */
    SlangResult EndAppendBuffer(byte* buffer, nuint numChars);

    /** Write text to the writer
    @param chars The characters to write out
    @param numChars The amount of characters
    @returns SLANG_OK on success */
    SlangResult Write(byte* chars, nuint numChars);

    /** Flushes any content to the output */
    void Flush();

    /** Determines if the writer stream is to the console, and can be used to alter the output
    @returns Returns true if is a console writer */
    SlangBool IsConsole();

    /** Set the mode for the writer to use
    @param mode The mode to use
    @returns SLANG_OK on success */
    SlangResult SetMode(SlangWriterMode mode);
}


[UUID(0x197772c7, 0x0155, 0x4b91, 0x84, 0xe8, 0x66, 0x68, 0xba, 0xff, 0x06, 0x19)]
public unsafe interface ISlangProfiler : IUnknown
{
    nuint GetEntryCount();
    byte* GetEntryName(uint index);
    long GetEntryTimeMS(uint index);
    uint GetEntryInvocationTimes(uint index);
}


/*!
@brief Callback type used for diagnostic output.
*/
// typedef void (* SlangDiagnosticCallback) (byte* message, void* userData);

/*
Forward declarations of types used in the reflection interface;
*/

public enum SlangReflectionGenericArgType : int
{
    TYPE = 0,
    INT = 1,
    BOOL = 2
};

// type reflection
public enum SlangTypeKind : uint
{
    NONE,
    STRUCT,
    ARRAY,
    MATRIX,
    VECTOR,
    SCALAR,
    CONSTANT_BUFFER,
    RESOURCE,
    SAMPLER_STATE,
    TEXTURE_BUFFER,
    SHADER_STORAGE_BUFFER,
    PARAMETER_BLOCK,
    GENERIC_TYPE_PARAMETER,
    INTERFACE,
    OUTPUT_STREAM,
    MESH_OUTPUT,
    SPECIALIZED,
    FEEDBACK,
    POINTER,
    DYNAMIC_RESOURCE,
    COUNT,
};


public enum SlangScalarType : uint
{
    NONE,
    VOID,
    BOOL,
    INT32,
    UINT32,
    INT64,
    UINT64,
    FLOAT16,
    FLOAT32,
    FLOAT64,
    INT8,
    UINT8,
    INT16,
    UINT16,
    INTPTR,
    UINTPTR
};


// abstract decl reflection
public enum SlangDeclKind : uint
{
    UNSUPPORTED_FOR_REFLECTION,
    STRUCT,
    FUNC,
    MODULE,
    GENERIC,
    VARIABLE,
    NAMESPACE
};


public enum SlangResourceShape : uint
{
    RESOURCE_BASE_SHAPE_MASK = 0x0F,

    RESOURCE_NONE = 0x00,

    TEXTURE_1D = 0x01,
    TEXTURE_2D = 0x02,
    TEXTURE_3D = 0x03,
    TEXTURE_CUBE = 0x04,
    TEXTURE_BUFFER = 0x05,

    STRUCTURED_BUFFER = 0x06,
    BYTE_ADDRESS_BUFFER = 0x07,
    RESOURCE_UNKNOWN = 0x08,
    ACCELERATION_STRUCTURE = 0x09,
    TEXTURE_SUBPASS = 0x0A,

    RESOURCE_EXT_SHAPE_MASK = 0xF0,

    TEXTURE_FEEDBACK_FLAG = 0x10,
    TEXTURE_SHADOW_FLAG = 0x20,
    TEXTURE_ARRAY_FLAG = 0x40,
    TEXTURE_MULTISAMPLE_FLAG = 0x80,

    SLANG_TEXTURE_1D_ARRAY = TEXTURE_1D | TEXTURE_ARRAY_FLAG,
    SLANG_TEXTURE_2D_ARRAY = TEXTURE_2D | TEXTURE_ARRAY_FLAG,
    SLANG_TEXTURE_CUBE_ARRAY = TEXTURE_CUBE | TEXTURE_ARRAY_FLAG,

    SLANG_TEXTURE_2D_MULTISAMPLE = TEXTURE_2D | TEXTURE_MULTISAMPLE_FLAG,
    SLANG_TEXTURE_2D_MULTISAMPLE_ARRAY =
        TEXTURE_2D | TEXTURE_MULTISAMPLE_FLAG | TEXTURE_ARRAY_FLAG,
    SLANG_TEXTURE_SUBPASS_MULTISAMPLE = TEXTURE_SUBPASS | TEXTURE_MULTISAMPLE_FLAG,
}


public enum SlangResourceAccess : uint
{
    NONE,
    READ,
    READ_WRITE,
    RASTER_ORDERED,
    APPEND,
    CONSUME,
    WRITE,
    FEEDBACK,
    UNKNOWN = 0x7FFFFFFF,
};


public enum SlangParameterCategory : uint
{
    NONE,
    MIXED,
    CONSTANT_BUFFER,
    SHADER_RESOURCE,
    UNORDERED_ACCESS,
    VARYING_INPUT,
    VARYING_OUTPUT,
    SAMPLER_STATE,
    UNIFORM,
    DESCRIPTOR_TABLE_SLOT,
    SPECIALIZATION_CONSTANT,
    PUSH_CONSTANT_BUFFER,

    // HLSL register `space`, Vulkan GLSL `set`
    REGISTER_SPACE,

    // TODO: Ellie, Both APIs treat mesh outputs as more or less varying output,
    // Does it deserve to be represented here??

    // A parameter whose type is to be specialized by a global generic type argument
    GENERIC,

    RAY_PAYLOAD,
    HIT_ATTRIBUTES,
    CALLABLE_PAYLOAD,
    SHADER_RECORD,

    // An existential type parameter represents a "hole" that
    // needs to be filled with a concrete type to enable
    // generation of specialized code.
    //
    // Consider this example:
    //
    //      struct MyParams
    //      {
    //          IMaterial material;
    //          ILight lights[3];
    //      };
    //
    // This `MyParams` type introduces two existential type parameters:
    // one for `material` and one for `lights`. Even though `lights`
    // is an array, it only introduces one type parameter, because
    // we need to have a *single* concrete type for all the array
    // elements to be able to generate specialized code.
    //
    EXISTENTIAL_TYPE_PARAM,

    // An existential object parameter represents a value
    // that needs to be passed in to provide data for some
    // interface-type shader parameter.
    //
    // Consider this example:
    //
    //      struct MyParams
    //      {
    //          IMaterial material;
    //          ILight lights[3];
    //      };
    //
    // This `MyParams` type introduces four existential object parameters:
    // one for `material` and three for `lights` (one for each array
    // element). This is consistent with the number of interface-type
    // "objects" that are being passed through to the shader.
    //
    EXISTENTIAL_OBJECT_PARAM,

    // The register space offset for the sub-elements that occupies register spaces.
    SUB_ELEMENT_REGISTER_SPACE,

    // The input_attachment_index subpass occupancy tracker
    SUBPASS,

    // Metal tier-1 argument buffer element [[id]].
    METAL_ARGUMENT_BUFFER_ELEMENT,

    // Metal [[attribute]] inputs.
    METAL_ATTRIBUTE,

    // Metal [[payload]] inputs
    METAL_PAYLOAD,

    //
    COUNT,

    // Aliases for Metal-specific categories.
    METAL_BUFFER = CONSTANT_BUFFER,
    METAL_TEXTURE = SHADER_RESOURCE,
    METAL_SAMPLER = SAMPLER_STATE,

    // DEPRECATED:
    VERTEX_INPUT = VARYING_INPUT,
    FRAGMENT_OUTPUT = VARYING_OUTPUT,
    COUNT_V1 = SUBPASS,
}

/** Types of API-managed bindings that a parameter might use.

`SlangBindingType` represents the distinct types of binding ranges that might be
understood by an underlying graphics API or cross-API abstraction layer.
Several of the enumeration cases here correspond to cases of `VkDescriptorType`
defined by the Vulkan API. Note however that the values of this enumeration
are not the same as those of any particular API.

The `SlangBindingType` enumeration is distinct from `SlangParameterCategory`
because `SlangParameterCategory` differentiates the types of parameters for
the purposes of layout, where the layout rules of some targets will treat
parameters of different types as occupying the same binding space for layout
(e.g., in SPIR-V both a `Texture2D` and `SamplerState` use the same space of
`binding` indices, and are not allowed to overlap), while those same types
map to different types of bindings in the API (e.g., both textures and samplers
use different `VkDescriptorType` values).

When you want to answer "what register/binding did this parameter use?" you
should use `SlangParameterCategory`.

When you want to answer "what type of descriptor range should this parameter use?"
you should use `SlangBindingType`.
*/
enum SlangBindingType : SlangUInt32
{
    UNKNOWN = 0,

    SAMPLER,
    TEXTURE,
    CONSTANT_BUFFER,
    PARAMETER_BLOCK,
    TYPED_BUFFER,
    RAW_BUFFER,
    COMBINED_TEXTURE_SAMPLER,
    INPUT_RENDER_TARGET,
    INLINE_UNIFORM_DATA,
    RAY_TRACING_ACCELERATION_STRUCTURE,

    VARYING_INPUT,
    VARYING_OUTPUT,

    EXISTENTIAL_VALUE,
    PUSH_CONSTANT,

    MUTABLE_FLAG = 0x100,

    MUTABLE_TETURE =
        TEXTURE | MUTABLE_FLAG,
    MUTABLE_TYPED_BUFFER =
        TYPED_BUFFER | MUTABLE_FLAG,
    MUTABLE_RAW_BUFFER =
        RAW_BUFFER | MUTABLE_FLAG,

    BASE_MASK = 0x00FF,
    EXT_MASK = 0xFF00,
}


public enum SlangLayoutRules : SlangUInt32
{
    DEFAULT,
    METAL_ARGUMENT_BUFFER_TIER_2,
};


public enum SlangModifierID : SlangUInt32
{
    SHARED,
    NO_DIFF,
    STATIC,
    CONST,
    EXPORT,
    EXTERN,
    DIFFERENTIABLE,
    MUTATING,
    IN,
    OUT,
    INOUT
};


enum SlangImageFormat : SlangUInt32
{
    unknown,
    rgba32f,
    rgba16f,
    rg32f,
    rg16f,
    r11f_g11f_b10f,
    r32f,
    r16f,
    rgba16,
    rgb10_a2,
    rgba8,
    rg16,
    rg8,
    r16,
    r8,
    rgba16_snorm,
    rgba8_snorm,
    rg16_snorm,
    rg8_snorm,
    r16_snorm,
    r8_snorm,
    rgba32i,
    rgba16i,
    rgba8i,
    rg32i,
    rg16i,
    rg8i,
    r32i,
    r16i,
    r8i,
    rgba32ui,
    rgba16ui,
    rgb10_a2ui,
    rgba8ui,
    rg32ui,
    rg16ui,
    rg8ui,
    r32ui,
    r16ui,
    r8ui,
    r64ui,
    r64i,
    bgra8,
}


public struct CompileCoreModuleFlag
{
    public enum Enum : uint
    {
        WriteDocumentation = 0x1,
    };
};

public enum BuiltinModuleName : int
{
    Core,
    GLSL
};

/** A global session for interaction with the Slang library.

An application may create and re-use a single global session across
multiple sessions, in order to amortize startups costs (in current
Slang this is mostly the cost of loading the Slang standard library).

The global session is currently *not* thread-safe and objects created from
a single global session should only be used from a single thread at
a time.
*/
[UUID(0xc140b5fd, 0xc78, 0x452e, 0xba, 0x7c, 0x1a, 0x1e, 0x70, 0xc7, 0xf7, 0x1c)]
public unsafe interface IGlobalSession : IUnknown
{
    /** Create a new session for loading and compiling code.
     */
    SlangResult CreateSession(SessionDesc* desc, out ISession* outSession);

    /** Look up the internal ID of a profile by its `name`.

    Profile IDs are *not* guaranteed to be stable across versions
    of the Slang library, so clients are expected to look up
    profiles by name at runtime.
    */
    SlangProfileID FindProfile(byte* name);

    /** Set the path that downstream compilers (aka back end compilers) will
    be looked from.
    @param passThrough Identifies the downstream compiler
    @param path The path to find the downstream compiler (shared library/dll/executable)

    For back ends that are dlls/shared libraries, it will mean the path will
    be prefixed with the path when calls are made out to ISlangSharedLibraryLoader.
    For executables - it will look for executables along the path */
    void SetDownstreamCompilerPath(SlangPassThrough passThrough, byte* path);

    /** DEPRECATED: Use setLanguagePrelude

    Set the 'prelude' for generated code for a 'downstream compiler'.
    @param passThrough The downstream compiler for generated code that will have the prelude applied
    to it.
    @param preludeText The text added pre-pended verbatim before the generated source

    That for pass-through usage, prelude is not pre-pended, preludes are for code generation only.
    */
    void SetDownstreamCompilerPrelude(SlangPassThrough passThrough, byte* preludeText);

    /** DEPRECATED: Use getLanguagePrelude

    Get the 'prelude' for generated code for a 'downstream compiler'.
    @param passThrough The downstream compiler for generated code that will have the prelude applied
    to it.
    @param outPrelude  On exit holds a blob that holds the string of the prelude.
    */
    void GetDownstreamCompilerPrelude(SlangPassThrough passThrough, out ISlangBlob* outPrelude);

    /** Get the build version 'tag' string. The string is the same as produced via `git describe
    --tags` for the project. If Slang is built separately from the automated build scripts the
    contents will by default be 'unknown'. Any string can be set by changing the contents of
    'slang-tag-version.h' file and recompiling the project.

    This method will return exactly the same result as the free function spGetBuildTagString.

    @return The build tag string
    */
    byte* GetBuildTagString();

    /* For a given source language set the default compiler.
    If a default cannot be chosen (for example the target cannot be achieved by the default),
    the default will not be used.

    @param sourceLanguage the source language
    @param defaultCompiler the default compiler for that language
    @return
    */
    SlangResult SetDefaultDownstreamCompiler(SlangSourceLanguage sourceLanguage, SlangPassThrough defaultCompiler);

    /* For a source type get the default compiler

    @param sourceLanguage the source language
    @return The downstream compiler for that source language */
    SlangPassThrough GetDefaultDownstreamCompiler(SlangSourceLanguage sourceLanguage);

    /* Set the 'prelude' placed before generated code for a specific language type.

    @param sourceLanguage The language the prelude should be inserted on.
    @param preludeText The text added pre-pended verbatim before the generated source

    Note! That for pass-through usage, prelude is not pre-pended, preludes are for code generation
    only.
    */
    void SetLanguagePrelude(SlangSourceLanguage sourceLanguage, byte* preludeText);

    /** Get the 'prelude' associated with a specific source language.
    @param sourceLanguage The language the prelude should be inserted on.
    @param outPrelude  On exit holds a blob that holds the string of the prelude.
    */
    void GetLanguagePrelude(SlangSourceLanguage sourceLanguage, out ISlangBlob* outPrelude);

    /** Create a compile request.
     */
    SlangResult CreateCompileRequest(out /* ICompileRequest */ void* outCompileRequest);

    /** Add new builtin declarations to be used in subsequent compiles.
     */
    void AddBuiltins(byte* sourcePath, byte* sourceString);

    /** Set the session shared library loader. If this changes the loader, it may cause shared
    libraries to be unloaded
    @param loader The loader to set. Setting null sets the default loader.
    */
    void SetSharedLibraryLoader(ISlangSharedLibraryLoader* loader);

    /** Gets the currently set shared library loader
    @return Gets the currently set loader. If returns null, it's the default loader
    */
    ISlangSharedLibraryLoader* GetSharedLibraryLoader();

    /** Returns SLANG_OK if the compilation target is supported for this session

    @param target The compilation target to test
    @return SLANG_OK if the target is available
    SLANG_E_NOT_IMPLEMENTED if not implemented in this build
    SLANG_E_NOT_FOUND if other resources (such as shared libraries) required to make target work
    could not be found SLANG_FAIL other kinds of failures */
    SlangResult CheckCompileTargetSupport(SlangCompileTarget target);

    /** Returns SLANG_OK if the pass through support is supported for this session
    @param session Session
    @param target The compilation target to test
    @return SLANG_OK if the target is available
    SLANG_E_NOT_IMPLEMENTED if not implemented in this build
    SLANG_E_NOT_FOUND if other resources (such as shared libraries) required to make target work
    could not be found SLANG_FAIL other kinds of failures */
    SlangResult CheckPassThroughSupport(SlangPassThrough passThrough);

    /** Compile from (embedded source) the core module on the session.
    Will return a failure if there is already a core module available
    NOTE! API is experimental and not ready for production code
    @param flags to control compilation
    */
    SlangResult CompileCoreModule(CompileCoreModuleFlag.Enum flags);

    /** Load the core module. Currently loads modules from the file system.
    @param coreModule Start address of the serialized core module
    @param coreModuleSizeInBytes The size in bytes of the serialized core module

    NOTE! API is experimental and not ready for production code
    */
    SlangResult LoadCoreModule(void* coreModule, nuint coreModuleSizeInBytes);

    /** Save the core module to the file system
    @param archiveType The type of archive used to hold the core module
    @param outBlob The serialized blob containing the core module

    NOTE! API is experimental and not ready for production code  */
    SlangResult SaveCoreModule(SlangArchiveType archiveType, out ISlangBlob* outBlob);

    /** Look up the internal ID of a capability by its `name`.

    Capability IDs are *not* guaranteed to be stable across versions
    of the Slang library, so clients are expected to look up
    capabilities by name at runtime.
    */
    SlangCapabilityID FindCapability(byte* name);

    /** Set the downstream/pass through compiler to be used for a transition from the source type to
    the target type
    @param source The source 'code gen target'
    @param target The target 'code gen target'
    @param compiler The compiler/pass through to use for the transition from source to target
    */
    void SetDownstreamCompilerForTransition(SlangCompileTarget source, SlangCompileTarget target, SlangPassThrough compiler);

    /** Get the downstream/pass through compiler for a transition specified by source and target
    @param source The source 'code gen target'
    @param target The target 'code gen target'
    @return The compiler that is used for the transition. Returns NONE it is not
    defined
    */
    SlangPassThrough GetDownstreamCompilerForTransition(SlangCompileTarget source, SlangCompileTarget target);

    /** Get the time in seconds spent in the slang and downstream compiler.
     */
    void GetCompilerElapsedTime(double* outTotalTime, double* outDownstreamTime);

    /** Specify a spirv.core.grammar.json file to load and use when
     * parsing and checking any SPIR-V code
     */
    SlangResult SetSPIRVCoreGrammar(byte* jsonPath);

    /** Parse slangc command line options into a SessionDesc that can be used to create a session
     *   with all the compiler options specified in the command line.
     *   @param argc The number of command line arguments.
     *   @param argv An input array of command line arguments to parse.
     *   @param outSessionDesc A pointer to a SessionDesc struct to receive parsed session desc.
     *   @param outAuxAllocation Auxiliary memory allocated to hold data used in the session desc.
     */
    SlangResult ParseCommandLineArguments(int argc, byte** argv, SessionDesc* outSessionDesc, out IUnknown* outAuxAllocation);

    /** Computes a digest that uniquely identifies the session description.
     */
    SlangResult GetSessionDescDigest(SessionDesc* sessionDesc, out ISlangBlob* outBlob);

    /** Compile from (embedded source) the builtin module on the session.
    Will return a failure if there is already a builtin module available.
    NOTE! API is experimental and not ready for production code.
    @param module The builtin module name.
    @param flags to control compilation
    */
    SlangResult CompileBuiltinModule(BuiltinModuleName module, CompileCoreModuleFlag.Enum flags);

    /** Load a builtin module. Currently loads modules from the file system.
    @param module The builtin module name
    @param moduleData Start address of the serialized core module
    @param sizeInBytes The size in bytes of the serialized builtin module

    NOTE! API is experimental and not ready for production code
    */
    SlangResult LoadBuiltinModule(BuiltinModuleName module, void* moduleData, nuint sizeInBytes);

    /** Save the builtin module to the file system
    @param module The builtin module name
    @param archiveType The type of archive used to hold the builtin module
    @param outBlob The serialized blob containing the builtin module

    NOTE! API is experimental and not ready for production code  */
    SlangResult SaveBuiltinModule(BuiltinModuleName module, SlangArchiveType archiveType, out ISlangBlob* outBlob);
}


/** Description of a code generation target.
 */
[StructLayout(LayoutKind.Sequential)]
public unsafe struct TargetDesc()
{
    /** The size of this structure, in bytes.
     */
    public nuint structureSize = (nuint)sizeof(TargetDesc);

    /** The target format to generate code for (e.g., SPIR-V, DXIL, etc.)
     */
    public SlangCompileTarget format = SlangCompileTarget.TARGET_UNKNOWN;

    /** The compilation profile supported by the target (e.g., "Shader Model 5.1")
     */
    public SlangProfileID profile = SlangProfileID.UNKNOWN;

    /** Flags for the code generation target. Currently unused. */
    public SlangTargetFlags flags = SlangTargetFlags.Default;

    /** Default mode to use for floating-point operations on the target.
     */
    public SlangFloatingPointMode floatingPointMode = SlangFloatingPointMode.DEFAULT;

    /** The line directive mode for output source code.
     */
    public SlangLineDirectiveMode lineDirectiveMode = SlangLineDirectiveMode.DEFAULT;

    /** Whether to force `scalar` layout for glsl shader storage buffers.
     */
    public bool forceGLSLScalarBufferLayout = false;

    /** Pointer to an array of compiler option entries, whose size is compilerOptionEntryCount.
     */
    public CompilerOptionEntry* compilerOptionEntries = null;

    /** Number of additional compiler option entries.
     */
    public uint compilerOptionEntryCount = 0;
};


public enum SessionFlags : uint
{
    None = 0
};


[StructLayout(LayoutKind.Sequential)]
public unsafe struct PreprocessorMacroDesc
{
    byte* name;
    byte* value;
};


[StructLayout(LayoutKind.Sequential)]
public unsafe struct SessionDesc()
{
    /** The size of this structure, in bytes.
     */
    public nuint structureSize = (nuint)sizeof(SessionDesc);

    /** Code generation targets to include in the session.
     */
    public TargetDesc* targets = null;
    public SlangInt targetCount = 0;

    /** Flags to configure the session.
     */
    public SessionFlags flags = SessionFlags.None;

    /** Default layout to assume for variables with matrix types.
     */
    public SlangMatrixLayoutMode defaultMatrixLayoutMode = SlangMatrixLayoutMode.ROW_MAJOR;

    /** Paths to use when searching for `#include`d or `import`ed files.
     */
    public byte** searchPaths = null;
    public SlangInt searchPathCount = 0;

    public PreprocessorMacroDesc* preprocessorMacros = null;
    public SlangInt preprocessorMacroCount = 0;

    public ISlangFileSystem* fileSystem = null;

    public bool enableEffectAnnotations = false;
    public bool allowGLSLSyntax = false;

    /** Pointer to an array of compiler option entries, whose size is compilerOptionEntryCount.
     */
    public CompilerOptionEntry* compilerOptionEntries = null;

    /** Number of additional compiler option entries.
     */
    public uint compilerOptionEntryCount = 0;
};


public enum ContainerType : int
{
    None,
    UnsizedArray,
    StructuredBuffer,
    ConstantBuffer,
    ParameterBlock
};


/** A session provides a scope for code that is loaded.

A session can be used to load modules of Slang source code,
and to request target-specific compiled binaries and layout
information.

In order to be able to load code, the session owns a set
of active "search paths" for resolving `#include` directives
and `import` declarations, as well as a set of global
preprocessor definitions that will be used for all code
that gets `import`ed in the session.

If multiple user shaders are loaded in the same session,
and import the same module (e.g., two source files do `import X`)
then there will only be one copy of `X` loaded within the session.

In order to be able to generate target code, the session
owns a list of available compilation targets, which specify
code generation options.

Code loaded and compiled within a session is owned by the session
and will remain resident in memory until the session is released.
Applications wishing to control the memory usage for compiled
and loaded code should use multiple sessions.
*/
[UUID(0x67618701, 0xd116, 0x468f, 0xab, 0x3b, 0x47, 0x4b, 0xed, 0xce, 0xe, 0x3d)]
public unsafe interface ISession : IUnknown
{
    /** Get the global session thas was used to create this session.
     */
    IGlobalSession* GetGlobalSession();

    /** Load a module as it would be by code using `import`.
     */
    IModule* LoadModule(byte* moduleName, out ISlangBlob* outDiagnostics);

    /** Load a module from Slang source code.
     */
    IModule* loadModuleFromSource(byte* moduleName, byte* path, ISlangBlob* source, out ISlangBlob* outDiagnostics);

    /** Combine multiple component types to create a composite component type.

    The `componentTypes` array must contain `componentTypeCount` pointers
    to component types that were loaded or created using the same session.

    The shader parameters and specialization parameters of the composite will
    be the union of those in `componentTypes`. The relative order of child
    component types is significant, and will affect the order in which
    parameters are reflected and laid out.

    The entry-point functions of the composite will be the union of those in
    `componentTypes`, and will follow the ordering of `componentTypes`.

    The requirements of the composite component type will be a subset of
    those in `componentTypes`. If an entry in `componentTypes` has a requirement
    that can be satisfied by another entry, then the composition will
    satisfy the requirement and it will not appear as a requirement of
    the composite. If multiple entries in `componentTypes` have a requirement
    for the same type, then only the first such requirement will be retained
    on the composite. The relative ordering of requirements on the composite
    will otherwise match that of `componentTypes`.

    If any diagnostics are generated during creation of the composite, they
    will be written to `outDiagnostics`. If an error is encountered, the
    function will return null.

    It is an error to create a composite component type that recursively
    aggregates a single module more than once.
    */
    SlangResult CreateCompositeComponentType(IComponentType** componentTypes, SlangInt componentTypeCount, out IComponentType* outCompositeComponentType, out ISlangBlob* outDiagnostics);

    /** Specialize a type based on type arguments.
     */
    /* TypeReflection */
    void SpecializeType(/* TypeReflection */ void* type, /* SpecializationArg */ void* specializationArgs, SlangInt specializationArgCount, out ISlangBlob* outDiagnostics);


    /** Get the layout `type` on the chosen `target`.
     */
    /* TypeLayoutReflection */
    void getTypeLayout(/* TypeReflection */ void* type, SlangInt targetIndex, SlangLayoutRules rules, out ISlangBlob* outDiagnostics);

    /** Get a container type from `elementType`. For example, given type `T`, returns
        a type that represents `StructuredBuffer<T>`.

        @param `elementType`: the element type to wrap around.
        @param `containerType`: the type of the container to wrap `elementType` in.
        @param `outDiagnostics`: a blob to receive diagnostic messages.
    */
    /* TypeReflection */
    void getContainerType(/* TypeReflection */ void* elementType, ContainerType containerType, out ISlangBlob* outDiagnostics);

    /** Return a `TypeReflection` that represents the `__Dynamic` type.
        This type can be used as a specialization argument to indicate using
        dynamic dispatch.
    */
    /* TypeReflection */
    void getDynamicType();

    /** Get the mangled name for a type RTTI object.
     */
    SlangResult GetTypeRTTIMangledName(/* TypeReflection */ void* type, out ISlangBlob* outNameBlob);

    /** Get the mangled name for a type witness.
     */
    SlangResult getTypeConformanceWitnessMangledName(/* TypeReflection */ void* type, /* TypeReflection */ void* interfaceType, out ISlangBlob* outNameBlob);

    /** Get the sequential ID used to identify a type witness in a dynamic object.
     */
    SlangResult getTypeConformanceWitnessSequentialID(/* TypeReflection */ void* type, /* TypeReflection */ void* interfaceType, out uint outId);

    /** Create a request to load/compile front-end code.
     */
    SlangResult CreateCompileRequest(/* SlangCompileRequest */ void* outCompileRequest);


    /** Creates a `IComponentType` that represents a type's conformance to an interface.
        The retrieved `ITypeConformance` objects can be included in a composite `IComponentType`
        to explicitly specify which implementation types should be included in the final compiled
        code. For example, if an module defines `IMaterial` interface and `AMaterial`,
        `BMaterial`, `CMaterial` types that implements the interface, the user can exclude
        `CMaterial` implementation from the resulting shader code by explicitly adding
        `AMaterial:IMaterial` and `BMaterial:IMaterial` conformances to a composite
        `IComponentType` and get entry point code from it. The resulting code will not have
        anything related to `CMaterial` in the dynamic dispatch logic. If the user does not
        explicitly include any `TypeConformances` to an interface type, all implementations to
        that interface will be included by default. By linking a `ITypeConformance`, the user is
        also given the opportunity to specify the dispatch ID of the implementation type. If
        `conformanceIdOverride` is -1, there will be no override behavior and Slang will
        automatically assign IDs to implementation types. The automatically assigned IDs can be
        queried via `ISession::getTypeConformanceWitnessSequentialID`.

        Returns SLANG_OK if succeeds, or SLANG_FAIL if `type` does not conform to `interfaceType`.
    */
    SlangResult CreateTypeConformanceComponentType(/* TypeReflection */ void* type, /* TypeReflection */ void* interfaceType, out ITypeConformance* outConformance, SlangInt conformanceIdOverride, out ISlangBlob* outDiagnostics);

    /** Load a module from a Slang module blob.
     */
    IModule LoadModuleFromIRBlob(byte* moduleName, byte* path, ISlangBlob* source, out ISlangBlob* outDiagnostics);

    SlangInt GetLoadedModuleCount();

    IModule GetLoadedModule(SlangInt index);

    /** Checks if a precompiled binary module is up-to-date with the current compiler
     *   option settings and the source file contents.
     */
    bool IsBinaryModuleUpToDate(byte* modulePath, ISlangBlob* binaryModuleBlob);

    /** Load a module from a string.
     */
    IModule loadModuleFromSourceString(byte* moduleName, byte* path, byte* srcString, out ISlangBlob* outDiagnostics);
}


[UUID(0x8044a8a3, 0xddc0, 0x4b7f, 0xaf, 0x8e, 0x2, 0x6e, 0x90, 0x5d, 0x73, 0x32)]
public interface IMetadata : ISlangCastable
{
    /*
    Returns whether a resource parameter at the specified binding location is actually being used
    in the compiled shader.
    */
    SlangResult IsParameterLocationUsed(
        SlangParameterCategory category, // is this a `t` register? `s` register?
        SlangUInt spaceIndex,            // `space` for D3D12, `set` for Vulkan
        SlangUInt registerIndex,         // `register` for D3D12, `binding` for Vulkan
        out bool outUsed);
}

/** A component type is a unit of shader code layout, reflection, and linking.

A component type is a unit of shader code that can be included into
a linked and compiled shader program. Each component type may have:

* Zero or more uniform shader parameters, representing textures,
  buffers, etc. that the code in the component depends on.

* Zero or more *specialization* parameters, which are type or
  value parameters that can be used to synthesize specialized
  versions of the component type.

* Zero or more entry points, which are the individually invocable
  kernels that can have final code generated.

* Zero or more *requirements*, which are other component
  types on which the component type depends.

One example of a component type is a module of Slang code:

* The global-scope shader parameters declared in the module are
  the parameters when considered as a component type.

* Any global-scope generic or interface type parameters introduce
  specialization parameters for the module.

* A module does not by default include any entry points when
  considered as a component type (although the code of the
  module might *declare* some entry points).

* Any other modules that are `import`ed in the source code
  become requirements of the module, when considered as a
  component type.

An entry point is another example of a component type:

* The `uniform` parameters of the entry point function are
  its shader parameters when considered as a component type.

* Any generic or interface-type parameters of the entry point
  introduce specialization parameters.

* An entry point component type exposes a single entry point (itself).

* An entry point has one requirement for the module in which
  it was defined.

Component types can be manipulated in a few ways:

* Multiple component types can be combined into a composite, which
  combines all of their code, parameters, etc.

* A component type can be specialized, by "plugging in" types and
  values for its specialization parameters.

* A component type can be laid out for a particular target, giving
  offsets/bindings to the shader parameters it contains.

* Generated kernel code can be requested for entry points.

*/
[UUID(0x5bc42be8, 0x5c50, 0x4929, 0x9e, 0x5e, 0xd1, 0x5e, 0x7c, 0x24, 0x1, 0x5f)]
public unsafe interface IComponentType : IUnknown
{

    /** Get the runtime session that this component type belongs to.
     */
    ISession getSession();

    /** Get the layout for this program for the chosen `targetIndex`.

    The resulting layout will establish offsets/bindings for all
    of the global and entry-point shader parameters in the
    component type.

    If this component type has specialization parameters (that is,
    it is not fully specialized), then the resulting layout may
    be incomplete, and plugging in arguments for generic specialization
    parameters may result in a component type that doesn't have
    a compatible layout. If the component type only uses
    interface-type specialization parameters, then the layout
    for a specialization should be compatible with an unspecialized
    layout (all parameters in the unspecialized layout will have
    the same offset/binding in the specialized layout).

    If this component type is combined into a composite, then
    the absolute offsets/bindings of parameters may not stay the same.
    If the shader parameters in a component type don't make
    use of explicit binding annotations (e.g., `register(...)`),
    then the *relative* offset of shader parameters will stay
    the same when it is used in a composition.
    */
    /* ProgramLayout */
    void getLayout(SlangInt targetIndex, out ISlangBlob* outDiagnostics);

    /** Get the number of (unspecialized) specialization parameters for the component type.
     */
    SlangInt getSpecializationParamCount();

    /** Get the compiled code for the entry point at `entryPointIndex` for the chosen `targetIndex`

    Entry point code can only be computed for a component type that
    has no specialization parameters (it must be fully specialized)
    and that has no requirements (it must be fully linked).

    If code has not already been generated for the given entry point and target,
    then a compilation error may be detected, in which case `outDiagnostics`
    (if non-null) will be filled in with a blob of messages diagnosing the error.
    */
    SlangResult getEntryPointCode(
        SlangInt entryPointIndex,
        SlangInt targetIndex,
        out ISlangBlob* outCode,
        out ISlangBlob* outDiagnostics);

    /** Get the compilation result as a file system.

    Has the same requirements as getEntryPointCode.

    The result is not written to the actual OS file system, but is made available as an
    in memory representation.
    */
    SlangResult getResultAsFileSystem(
        SlangInt entryPointIndex,
        SlangInt targetIndex,
        out ISlangMutableFileSystem* outFileSystem);

    /** Compute a hash for the entry point at `entryPointIndex` for the chosen `targetIndex`.

    This computes a hash based on all the dependencies for this component type as well as the
    target settings affecting the compiler backend. The computed hash is used as a key for caching
    the output of the compiler backend to implement shader caching.
    */
    void GetEntryPointHash(SlangInt entryPointIndex, SlangInt targetIndex, out ISlangBlob* outHash);

    /** Specialize the component by binding its specialization parameters to concrete arguments.

    The `specializationArgs` array must have `specializationArgCount` entries, and
    this must match the number of specialization parameters on this component type.

    If any diagnostics (error or warnings) are produced, they will be written to `outDiagnostics`.
    */
    SlangResult specialize(/* SpecializationArg */ void* specializationArgs, SlangInt specializationArgCount, out IComponentType* outSpecializedComponentType, out ISlangBlob* outDiagnostics);

    /** Link this component type against all of its unsatisfied dependencies.

    A component type may have unsatisfied dependencies. For example, a module
    depends on any other modules it `import`s, and an entry point depends
    on the module that defined it.

    A user can manually satisfy dependencies by creating a composite
    component type, and when doing so they retain full control over
    the relative ordering of shader parameters in the resulting layout.

    It is an error to try to generate/access compiled kernel code for
    a component type with unresolved dependencies, so if dependencies
    remain after whatever manual composition steps an application
    cares to perform, the `link()` function can be used to automatically
    compose in any remaining dependencies. The order of parameters
    (and hence the global layout) that results will be deterministic,
    but is not currently documented.
    */
    SlangResult Link(out IComponentType* outLinkedComponentType, out ISlangBlob* outDiagnostics);

    /** Get entry point 'callable' functions accessible through the ISlangSharedLibrary interface.

    The functions remain in scope as long as the ISlangSharedLibrary interface is in scope.

    NOTE! Requires a compilation target of SLANG_HOST_CALLABLE.

    @param entryPointIndex  The index of the entry point to get code for.
    @param targetIndex      The index of the target to get code for (default: zero).
    @param outSharedLibrary A pointer to a ISharedLibrary interface which functions can be queried
    on.
    @returns                A `SlangResult` to indicate success or failure.
    */
    SlangResult GetEntryPointHostCallable(int entryPointIndex, int targetIndex, out ISlangSharedLibrary* outSharedLibrary, out ISlangBlob* outDiagnostics);

    /** Get a new ComponentType object that represents a renamed entry point.

    The current object must be a single EntryPoint, or a CompositeComponentType or
    SpecializedComponentType that contains one EntryPoint component.
    */
    SlangResult RenameEntryPoint(byte* newName, out IComponentType* outEntryPoint);

    /** Link and specify additional compiler options when generating code
     *   from the linked program.
     */
    SlangResult linkWithOptions(
        out IComponentType* outLinkedComponentType,
        uint compilerOptionEntryCount,
        CompilerOptionEntry* compilerOptionEntries,
        out ISlangBlob* outDiagnostics);

    SlangResult GetTargetCode(SlangInt targetIndex, out ISlangBlob* outCode, out ISlangBlob* outDiagnostics);

    SlangResult getTargetMetadata(
        SlangInt targetIndex,
        out IMetadata* outMetadata,
        out ISlangBlob* outDiagnostics);

    SlangResult getEntryPointMetadata(
        SlangInt entryPointIndex,
        SlangInt targetIndex,
        out IMetadata* outMetadata,
        out ISlangBlob* outDiagnostics);
}


[UUID(0x8f241361, 0xf5bd, 0x4ca0, 0xa3, 0xac, 0x2, 0xf7, 0xfa, 0x24, 0x2, 0xb8)]
public interface IEntryPoint : IComponentType
{

    /* FunctionReflection */
    void getFunctionReflection();
}


[UUID(0x73eb3147, 0xe544, 0x41b5, 0xb8, 0xf0, 0xa2, 0x44, 0xdf, 0x21, 0x94, 0xb)]
public interface ITypeConformance : IComponentType
{
}


/** A module is the granularity of shader code compilation and loading.

In most cases a module corresponds to a single compile "translation unit."
This will often be a single `.slang` or `.hlsl` file and everything it
`#include`s.

Notably, a module `M` does *not* include the things it `import`s, as these
as distinct modules that `M` depends on. There is a directed graph of
module dependencies, and all modules in the graph must belong to the
same session (`ISession`).

A module establishes a namespace for looking up types, functions, etc.
*/
[UUID(0xc720e64, 0x8722, 0x4d31, 0x89, 0x90, 0x63, 0x8a, 0x98, 0xb1, 0xc2, 0x79)]
public unsafe interface IModule : IComponentType
{
    /// Find and an entry point by name.
    /// Note that this does not work in case the function is not explicitly designated as an entry
    /// point, e.g. using a `[shader("...")]` attribute. In such cases, consider using
    /// `IModule::findAndCheckEntryPoint` instead.
    SlangResult FindEntryPointByName(byte* name, out IEntryPoint* outEntryPoint);

    /// Get number of entry points defined in the module. An entry point defined in a module
    /// is by default not included in the linkage, so calls to `IComponentType::getEntryPointCount`
    /// on an `IModule` instance will always return 0. However `IModule::getDefinedEntryPointCount`
    /// will return the number of defined entry points.
    SlangInt32 getDefinedEntryPointCount();

    /// Get the name of an entry point defined in the module.
    SlangResult GetDefinedEntryPoint(SlangInt32 index, out IEntryPoint* outEntryPoint);

    /// Get a serialized representation of the checked module.
    SlangResult serialize(out ISlangBlob* outSerializedBlob);

    /// Write the serialized representation of this module to a file.
    SlangResult writeToFile(byte* fileName);

    /// Get the name of the module.
    byte* getName();

    /// Get the path of the module.
    byte* getFilePath();

    /// Get the unique identity of the module.
    byte* getUniqueIdentity();

    /// Find and validate an entry point by name, even if the function is
    /// not marked with the `[shader("...")]` attribute.
    SlangResult findAndCheckEntryPoint(
        byte* name,
        SlangStage stage,
        out IEntryPoint* outEntryPoint,
        out ISlangBlob* outDiagnostics);

    /// Get the number of dependency files that this module depends on.
    /// This includes both the explicit source files, as well as any
    /// additional files that were transitively referenced (e.g., via
    /// a `#include` directive).
    SlangInt32 getDependencyFileCount();

    /// Get the path to a file this module depends on.
    byte* getDependencyFilePath(SlangInt32 index);

    /* DeclReflection */
    void getModuleReflection();

    /** Disassemble a module.
     */
    SlangResult Disassemble(out ISlangBlob* outDisassembledBlob);
}
;

/* Experimental interface for doing target precompilation of slang modules */
[UUID(0x8e12e8e3, 0x5fcd, 0x433e, 0xaf, 0xcb, 0x13, 0xa0, 0x88, 0xbc, 0x5e, 0xe5)]
public unsafe interface IModulePrecompileService_Experimental : IUnknown
{
    SlangResult PrecompileForTarget(SlangCompileTarget target, out ISlangBlob* outDiagnostics);

    SlangResult GetPrecompiledTargetCode(
        SlangCompileTarget target,
        out ISlangBlob* outCode,
        out ISlangBlob* outDiagnostics);

    SlangInt getModuleDependencyCount();

    SlangResult getModuleDependency(
        SlangInt dependencyIndex,
        out IModule* outModule,
        out ISlangBlob* outDiagnostics);
}

// Passed into functions to create globalSession to identify the API version client code is
// using.

enum SlangLanguageVersion
{
    VERSION_2025 = 2025
};


/* Description of a Slang global session.
 */
[StructLayout(LayoutKind.Sequential)]
unsafe struct SlangGlobalSessionDesc()
{
    /// Size of this struct.
    uint structureSize = (uint)sizeof(SlangGlobalSessionDesc);

    /// Slang API version.
    uint apiVersion = 0;

    /// Slang language version.
    uint languageVersion = 2025;

    /// Whether to enable GLSL support.
    bool enableGLSL = false;

    /// Reserved for future use.
    fixed uint reserved[16];
};
