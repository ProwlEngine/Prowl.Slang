using System;

namespace Prowl.Slang.Native;

/*!
@brief Severity of a diagnostic generated by the compiler.
Values come from the enum below, with higher values representing more severe
conditions, and all values >= SLANG_SEVERITY_ERROR indicating compilation
failure.
*/
public enum SlangSeverity : int
{
    Disabled = 0, /**< A message that is disabled, filtered out. */
    Note,         /**< An informative message. */
    Warning,      /**< A warning, which indicates a possible problem. */
    Error,        /**< An error, indicating that compilation failed. */
    Fatal,    /**< An unrecoverable error, which forced compilation to abort. */
    Internal, /**< An internal error, indicating a logic error in the compiler.
                                  */
}


[Flags]
public enum SlangDiagnosticFlags : int
{
    VerbosePaths = 0x01,
    TreatWarningsAsErrors = 0x02
}


public enum SlangBindableResourceType : int
{
    NonBindable = 0,
    Texture,
    Sampler,
    UniformBuffer,
    StorageBuffer,
}


/* NOTE! To keep binary compatibility care is needed with this enum!

* To add value, only add at the bottom (before COUNT_OF)
* To remove a value, add _DEPRECATED as a suffix, but leave in the list

This will make the enum values stable, and compatible with libraries that might not use the
latest enum values.
*/
public enum SlangCompileTarget : int
{
    TARGET_UNKNOWN,
    TARGET_NONE,
    GLSL,
    GLSL_VULKAN_DEPRECATED,          //< deprecated and removed: just use `SLANG_GLSL`.
    GLSL_VULKAN_ONE_DESC_DEPRECATED, //< deprecated and removed.
    HLSL,
    SPIRV,
    SPIRV_ASM,
    DXBC,
    DXBC_ASM,
    DXIL,
    DXIL_ASM,
    C_SOURCE,              ///< The C language
    CPP_SOURCE,            ///< C++ code for shader kernels.
    HOST_EXECUTABLE,       ///< Standalone binary executable (for hosting CPU/OS)
    SHADER_SHARED_LIBRARY, ///< A shared library/Dll for shader kernels (for hosting
                           ///< CPU/OS)
    SHADER_HOST_CALLABLE,  ///< A CPU target that makes the compiled shader code available
                           ///< to be run immediately
    CUDA_SOURCE,           ///< Cuda source
    PTX,                   ///< PTX
    CUDA_OBJECT_CODE,      ///< Object code that contains CUDA functions.
    OBJECT_CODE,           ///< Object code that can be used for later linking
    HOST_CPP_SOURCE,       ///< C++ code for host library or executable.
    HOST_HOST_CALLABLE,    ///< Host callable host code (ie non kernel/shader)
    CPP_PYTORCH_BINDING,   ///< C++ PyTorch binding code.
    METAL,                 ///< Metal shading language
    METAL_LIB,             ///< Metal library
    METAL_LIB_ASM,         ///< Metal library assembly
    HOST_SHARED_LIBRARY,   ///< A shared library/Dll for host code (for hosting CPU/OS)
    WGSL,                  ///< WebGPU shading language
    WGSL_SPIRV_ASM,        ///< SPIR-V assembly via WebGPU shading language
    WGSL_SPIRV,            ///< SPIR-V via WebGPU shading language
}


/* A "container format" describes the way that the outputs
for multiple files, entry points, targets, etc. should be
combined into a single artifact for output. */
public enum SlangContainerFormat : int
{
    /* Don't generate a container. */
    NONE,

    /* Generate a container in the `.slang-module` format,
    which includes reflection information, compiled kernels, etc. */
    SLANG_MODULE,
}


public enum SlangPassThrough : int
{
    NONE,
    FXC,
    DXC,
    GLSLANG,
    SPIRV_DIS,
    CLANG,         ///< Clang C/C++ compiler
    VISUAL_STUDIO, ///< Visual studio C/C++ compiler
    GCC,           ///< GCC C/C++ compiler
    GENERIC_C_CPP, ///< Generic C or C++ compiler, which is decided by the
                   ///< source type
    NVRTC,         ///< NVRTC Cuda compiler
    LLVM,          ///< LLVM 'compiler' - includes LLVM and Clang
    SPIRV_OPT,     ///< SPIRV-opt
    METAL,         ///< Metal compiler
    TINT,          ///< Tint WGSL compiler
    SPIRV_LINK,    ///< SPIRV-link
}


/* Defines an archive type used to holds a 'file system' type structure. */
public enum SlangArchiveType : int
{
    UNDEFINED,
    ZIP,
    RIFF, ///< Riff container with no compression
    RIFF_DEFLATE,
    RIFF_LZ4,
}


/*!
Flags to control compilation behavior.
*/
[Flags]
public enum SlangCompileFlags : uint
{
    /* Do as little mangling of names as possible, to try to preserve original names */
    NO_MANGLING = 1 << 3,

    /* Skip code generation step, just check the code and generate layout */
    NO_CODEGEN = 1 << 4,

    /* Obfuscate shader names on release products */
    OBFUSCATE = 1 << 5,

    /* Deprecated flags: kept around to allow existing applications to
    compile. Note that the relevant features will still be left in
    their default state. */
    NO_CHECKING = 0,
    SPLIT_MIXED_TYPES = 0,
}


/*!
@brief Flags to control code generation behavior of a compilation target */
[Flags]
public enum SlangTargetFlags : uint
{
    /* When compiling for a D3D Shader Model 5.1 or higher target, allocate
       distinct register spaces for parameter blocks.

       @deprecated This behavior is now enabled unconditionally.
    */
    PARAMETER_BLOCKS_USE_REGISTER_SPACES = 1 << 4,

    /* When set, will generate target code that contains all entrypoints defined
       in the input source or specified via the `spAddEntryPoint` function in a
       single output module (library/source file).
    */
    GENERATE_WHOLE_PROGRAM = 1 << 8,

    /* When set, will dump out the IR between intermediate compilation steps.*/
    DUMP_IR = 1 << 9,

    /* When set, will generate SPIRV directly rather than via glslang. */
    // This flag will be deprecated, use CompilerOption instead.
    GENERATE_SPIRV_DIRECTLY = 1 << 10,

    Default = GENERATE_SPIRV_DIRECTLY
}


/*!
@brief Options to control floating-point precision guarantees for a target.
*/
public enum SlangFloatingPointMode : uint
{
    DEFAULT = 0,
    FAST,
    PRECISE,
}


/*!
@brief Options to control emission of `#line` directives
*/
public enum SlangLineDirectiveMode : uint
{
    DEFAULT =
        0,                              /**< Default behavior: pick behavior base on target. */
    NONE,     /**< Don't emit line directives at all. */
    STANDARD, /**< Emit standard C-style `#line` directives. */
    GLSL, /**< Emit GLSL-style directives with file *number* instead
                                           of name */
    SOURCE_MAP, /**< Use a source map to track line mappings (ie no
                                                 #line will appear in emitting source) */
}


public enum SlangSourceLanguage : int
{
    UNKNOWN,
    SLANG,
    HLSL,
    GLSL,
    C,
    CPP,
    CUDA,
    SPIRV,
    METAL,
    WGSL,
}


public enum SlangProfileID : uint
{
    UNKNOWN,
}


public enum SlangCapabilityID : int
{
    UNKNOWN = 0,
}


public enum SlangMatrixLayoutMode : uint
{
    MODE_UNKNOWN = 0,
    ROW_MAJOR,
    COLUMN_MAJOR,
}


public enum SlangStage : uint
{
    NONE,
    VERTEX,
    HULL,
    DOMAIN,
    GEOMETRY,
    FRAGMENT,
    COMPUTE,
    RAY_GENERATION,
    INTERSECTION,
    ANY_HIT,
    CLOSEST_HIT,
    MISS,
    CALLABLE,
    MESH,
    AMPLIFICATION
}


public enum SlangDebugInfoLevel : uint
{
    NONE = 0, /**< Don't emit debug information at all. */
    MINIMAL,  /**< Emit as little debug information as possible, while
                                            still supporting stack trackers. */
    STANDARD, /**< Emit whatever is the standard level of debug
                                            information for each target. */
    MAXIMAL,  /**< Emit as much debug information as possible for each
                                            target. */
}


/* Describes the debugging information format produced during a compilation. */
public enum SlangDebugInfoFormat : uint
{
    DEFAULT, ///< Use the default debugging format for the target
    C7,  ///< CodeView C7 format (typically means debugging information
         ///< is embedded in the binary)
    PDB, ///< Program database

    STABS, ///< Stabs
    COFF,  ///< COFF debug info
    DWARF, ///< DWARF debug info (we may want to support specifying the
           ///< version)
}


public enum SlangOptimizationLevel : uint
{
    NONE = 0, /**< Don't optimize at all. */
    DEFAULT,  /**< Default optimization level: balance code quality and
                                              compilation time. */
    HIGH,     /**< Optimize aggressively. */
    MAXIMAL, /**< Include optimizations that may take a very long time,
                                             or may involve severe space-vs-speed tradeoffs */
}


public enum SlangEmitSpirvMethod : int
{
    DEFAULT = 0,
    VIA_GLSL,
    DIRECTLY,
}


public enum CompilerOptionName : int
{
    MacroDefine, // stringValue0: macro name;  stringValue1: macro value
    DepFile,
    EntryPointName,
    Specialize,
    Help,
    HelpStyle,
    Include, // stringValue: additional include path.
    Language,
    MatrixLayoutColumn,         // bool
    MatrixLayoutRow,            // bool
    ZeroInitialize,             // bool
    IgnoreCapabilities,         // bool
    RestrictiveCapabilityCheck, // bool
    ModuleName,                 // stringValue0: module name.
    Output,
    Profile, // intValue0: profile
    Stage,   // intValue0: stage
    Target,  // intValue0: CodeGenTarget
    Version,
    WarningsAsErrors, // stringValue0: "all" or comma separated list of warning codes or names.
    DisableWarnings,  // stringValue0: comma separated list of warning codes or names.
    EnableWarning,    // stringValue0: warning code or name.
    DisableWarning,   // stringValue0: warning code or name.
    DumpWarningDiagnostics,
    InputFilesRemain,
    EmitIr,                        // bool
    ReportDownstreamTime,          // bool
    ReportPerfBenchmark,           // bool
    ReportCheckpointIntermediates, // bool
    SkipSPIRVValidation,           // bool
    SourceEmbedStyle,
    SourceEmbedName,
    SourceEmbedLanguage,
    DisableShortCircuit,            // bool
    MinimumSlangOptimization,       // bool
    DisableNonEssentialValidations, // bool
    DisableSourceMap,               // bool
    UnscopedEnum,                   // bool
    PreserveParameters, // bool: preserve all resource parameters in the output code.

    // Target

    Capability,                // intValue0: CapabilityName
    DefaultImageFormatUnknown, // bool
    DisableDynamicDispatch,    // bool
    DisableSpecialization,     // bool
    FloatingPointMode,         // intValue0: FloatingPointMode
    DebugInformation,          // intValue0: DebugInfoLevel
    LineDirectiveMode,
    Optimization, // intValue0: OptimizationLevel
    Obfuscate,    // bool

    VulkanBindShift, // intValue0 (higher 8 bits): kind; intValue0(lower bits): set; intValue1:
                     // shift
    VulkanBindGlobals,       // intValue0: index; intValue1: set
    VulkanInvertY,           // bool
    VulkanUseDxPositionW,    // bool
    VulkanUseEntryPointName, // bool
    VulkanUseGLLayout,       // bool
    VulkanEmitReflection,    // bool

    GLSLForceScalarLayout,   // bool
    EnableEffectAnnotations, // bool

    EmitSpirvViaGLSL,     // bool (will be deprecated)
    EmitSpirvDirectly,    // bool (will be deprecated)
    SPIRVCoreGrammarJSON, // stringValue0: json path
    IncompleteLibrary,    // bool, when set, will not issue an error when the linked program has
                          // unresolved extern function symbols.

    // Downstream

    CompilerPath,
    DefaultDownstreamCompiler,
    DownstreamArgs, // stringValue0: downstream compiler name. stringValue1: argument list, one
                    // per line.
    PassThrough,

    // Repro

    DumpRepro,
    DumpReproOnError,
    ExtractRepro,
    LoadRepro,
    LoadReproDirectory,
    ReproFallbackDirectory,

    // Debugging

    DumpAst,
    DumpIntermediatePrefix,
    DumpIntermediates, // bool
    DumpIr,            // bool
    DumpIrIds,
    PreprocessorOutput,
    OutputIncludes,
    ReproFileSystem,
    SerialIr,    // bool
    SkipCodeGen, // bool
    ValidateIr,  // bool
    VerbosePaths,
    VerifyDebugSerialIr,
    NoCodeGen, // Not used.

    // Experimental

    FileSystem,
    Heterogeneous,
    NoMangle,
    NoHLSLBinding,
    NoHLSLPackConstantBufferElements,
    ValidateUniformity,
    AllowGLSL,
    EnableExperimentalPasses,
    BindlessSpaceIndex, // int

    // Internal

    ArchiveType,
    CompileCoreModule,
    Doc,
    IrCompression,
    LoadCoreModule,
    ReferenceModule,
    SaveCoreModule,
    SaveCoreModuleBinSource,
    TrackLiveness,
    LoopInversion, // bool, enable loop inversion optimization

    // Deprecated
    ParameterBlocksUseRegisterSpaces,

    CountOfParsableOptions,

    // Used in parsed options only.
    DebugInformationFormat,  // intValue0: DebugInfoFormat
    VulkanBindShiftAll,      // intValue0: kind; intValue1: shift
    GenerateWholeProgram,    // bool
    UseUpToDateBinaryModule, // bool, when set, will only load
                             // precompiled modules if it is up-to-date with its source.
    EmbedDownstreamIR,       // bool
    ForceDXLayout,           // bool

    // Add this new option to the end of the list to avoid breaking ABI as much as possible.
    // Setting of EmitSpirvDirectly or EmitSpirvViaGLSL will turn into this option internally.
    EmitSpirvMethod, // enum SlangEmitSpirvMethod

    EmitReflectionJSON, // bool
    SaveGLSLModuleBinSource,

    SkipDownstreamLinking, // bool, experimental
    DumpModule,
    CountOf,
}


public enum CompilerOptionValueKind : int
{
    Int,
    String
}




/* Type that identifies how a path should be interpreted */
public enum SlangPathType : uint
{
    DIRECTORY, /**< Path specified specifies a directory. */
    FILE,      /**< Path specified is to a file. */
};

/* Callback to enumerate the contents of of a directory in a ISlangFileSystemExt.
The name is the name of a file system object (directory/file) in the specified path (ie it is
without a path) */
// typedef void (
//         * FileSystemContentsCallBack) (SlangPathType pathType, byte* name, void* userData);

/* Determines how paths map to files on the OS file system */
public enum OSPathKind : byte
{
    None,            ///< Paths do not map to the file system
    Direct,          ///< Paths map directly to the file system
    OperatingSystem, ///< Only paths gained via PathKind::OperatingSystem map to the operating
                     ///< system file system
};

/* Used to determine what kind of path is required from an input path */
public enum PathKind : int
{
    /// Given a path, returns a simplified version of that path.
    /// This typically means removing '..' and/or '.' from the path.
    /// A simplified path must point to the same object as the original.
    Simplified,

    /// Given a path, returns a 'canonical path' to the item.
    /// This may be the operating system 'canonical path' that is the unique path to the item.
    ///
    /// If the item exists the returned canonical path should always be usable to access the
    /// item.
    ///
    /// If the item the path specifies doesn't exist, the canonical path may not be returnable
    /// or be a path simplification.
    /// Not all file systems support canonical paths.
    Canonical,

    /// Given a path returns a path such that it is suitable to be displayed to the user.
    ///
    /// For example if the file system is a zip file - it might include the path to the zip
    /// container as well as the path to the specific file.
    ///
    /// NOTE! The display path won't necessarily work on the file system to access the item
    Display,

    /// Get the path to the item on the *operating system* file system, if available.
    OperatingSystem,
}



/* Identifies different types of writer target*/
public enum SlangWriterChannel : uint
{
    DIAGNOSTIC,
    STD_OUTPUT,
    STD_ERROR,
};


public enum SlangWriterMode : uint
{
    TEXT,
    BINARY,
};




/*!
@brief Callback type used for diagnostic output.
*/
// typedef void (* SlangDiagnosticCallback) (byte* message, void* userData);

/*
Forward declarations of types used in the reflection interface;
*/

public enum SlangReflectionGenericArgType : int
{
    TYPE = 0,
    INT = 1,
    BOOL = 2
};

// type reflection
public enum SlangTypeKind : uint
{
    NONE,
    STRUCT,
    ARRAY,
    MATRIX,
    VECTOR,
    SCALAR,
    CONSTANT_BUFFER,
    RESOURCE,
    SAMPLER_STATE,
    TEXTURE_BUFFER,
    SHADER_STORAGE_BUFFER,
    PARAMETER_BLOCK,
    GENERIC_TYPE_PARAMETER,
    INTERFACE,
    OUTPUT_STREAM,
    MESH_OUTPUT,
    SPECIALIZED,
    FEEDBACK,
    POINTER,
    DYNAMIC_RESOURCE,
    COUNT,
};


public enum SlangScalarType : uint
{
    NONE,
    VOID,
    BOOL,
    INT32,
    UINT32,
    INT64,
    UINT64,
    FLOAT16,
    FLOAT32,
    FLOAT64,
    INT8,
    UINT8,
    INT16,
    UINT16,
    INTPTR,
    UINTPTR
};


// abstract decl reflection
public enum SlangDeclKind : uint
{
    UNSUPPORTED_FOR_REFLECTION,
    STRUCT,
    FUNC,
    MODULE,
    GENERIC,
    VARIABLE,
    NAMESPACE
};


public enum SlangResourceShape : uint
{
    RESOURCE_BASE_SHAPE_MASK = 0x0F,

    RESOURCE_NONE = 0x00,

    TEXTURE_1D = 0x01,
    TEXTURE_2D = 0x02,
    TEXTURE_3D = 0x03,
    TEXTURE_CUBE = 0x04,
    TEXTURE_BUFFER = 0x05,

    STRUCTURED_BUFFER = 0x06,
    BYTE_ADDRESS_BUFFER = 0x07,
    RESOURCE_UNKNOWN = 0x08,
    ACCELERATION_STRUCTURE = 0x09,
    TEXTURE_SUBPASS = 0x0A,

    RESOURCE_EXT_SHAPE_MASK = 0xF0,

    TEXTURE_FEEDBACK_FLAG = 0x10,
    TEXTURE_SHADOW_FLAG = 0x20,
    TEXTURE_ARRAY_FLAG = 0x40,
    TEXTURE_MULTISAMPLE_FLAG = 0x80,

    SLANG_TEXTURE_1D_ARRAY = TEXTURE_1D | TEXTURE_ARRAY_FLAG,
    SLANG_TEXTURE_2D_ARRAY = TEXTURE_2D | TEXTURE_ARRAY_FLAG,
    SLANG_TEXTURE_CUBE_ARRAY = TEXTURE_CUBE | TEXTURE_ARRAY_FLAG,

    SLANG_TEXTURE_2D_MULTISAMPLE = TEXTURE_2D | TEXTURE_MULTISAMPLE_FLAG,
    SLANG_TEXTURE_2D_MULTISAMPLE_ARRAY = TEXTURE_2D | TEXTURE_MULTISAMPLE_FLAG | TEXTURE_ARRAY_FLAG,
    SLANG_TEXTURE_SUBPASS_MULTISAMPLE = TEXTURE_SUBPASS | TEXTURE_MULTISAMPLE_FLAG,
}


public enum SlangResourceAccess : uint
{
    NONE,
    READ,
    READ_WRITE,
    RASTER_ORDERED,
    APPEND,
    CONSUME,
    WRITE,
    FEEDBACK,
    UNKNOWN = 0x7FFFFFFF,
};


public enum SlangParameterCategory : uint
{
    NONE,
    MIXED,
    CONSTANT_BUFFER,
    SHADER_RESOURCE,
    UNORDERED_ACCESS,
    VARYING_INPUT,
    VARYING_OUTPUT,
    SAMPLER_STATE,
    UNIFORM,
    DESCRIPTOR_TABLE_SLOT,
    SPECIALIZATION_CONSTANT,
    PUSH_CONSTANT_BUFFER,

    // HLSL register `space`, Vulkan GLSL `set`
    REGISTER_SPACE,

    // TODO: Ellie, Both APIs treat mesh outputs as more or less varying output,
    // Does it deserve to be represented here??

    // A parameter whose type is to be specialized by a global generic type argument
    GENERIC,

    RAY_PAYLOAD,
    HIT_ATTRIBUTES,
    CALLABLE_PAYLOAD,
    SHADER_RECORD,

    // An existential type parameter represents a "hole" that
    // needs to be filled with a concrete type to enable
    // generation of specialized code.
    //
    // Consider this example:
    //
    //      struct MyParams
    //      {
    //          IMaterial material;
    //          ILight lights[3];
    //      };
    //
    // This `MyParams` type introduces two existential type parameters:
    // one for `material` and one for `lights`. Even though `lights`
    // is an array, it only introduces one type parameter, because
    // we need to have a *single* concrete type for all the array
    // elements to be able to generate specialized code.
    //
    EXISTENTIAL_TYPE_PARAM,

    // An existential object parameter represents a value
    // that needs to be passed in to provide data for some
    // interface-type shader parameter.
    //
    // Consider this example:
    //
    //      struct MyParams
    //      {
    //          IMaterial material;
    //          ILight lights[3];
    //      };
    //
    // This `MyParams` type introduces four existential object parameters:
    // one for `material` and three for `lights` (one for each array
    // element). This is consistent with the number of interface-type
    // "objects" that are being passed through to the shader.
    //
    EXISTENTIAL_OBJECT_PARAM,

    // The register space offset for the sub-elements that occupies register spaces.
    SUB_ELEMENT_REGISTER_SPACE,

    // The input_attachment_index subpass occupancy tracker
    SUBPASS,

    // Metal tier-1 argument buffer element [[id]].
    METAL_ARGUMENT_BUFFER_ELEMENT,

    // Metal [[attribute]] inputs.
    METAL_ATTRIBUTE,

    // Metal [[payload]] inputs
    METAL_PAYLOAD,
}

/** Types of API-managed bindings that a parameter might use.

`SlangBindingType` represents the distinct types of binding ranges that might be
understood by an underlying graphics API or cross-API abstraction layer.
Several of the enumeration cases here correspond to cases of `VkDescriptorType`
defined by the Vulkan API. Note however that the values of this enumeration
are not the same as those of any particular API.

The `SlangBindingType` enumeration is distinct from `SlangParameterCategory`
because `SlangParameterCategory` differentiates the types of parameters for
the purposes of layout, where the layout rules of some targets will treat
parameters of different types as occupying the same binding space for layout
(e.g., in SPIR-V both a `Texture2D` and `SamplerState` use the same space of
`binding` indices, and are not allowed to overlap), while those same types
map to different types of bindings in the API (e.g., both textures and samplers
use different `VkDescriptorType` values).

When you want to answer "what register/binding did this parameter use?" you
should use `SlangParameterCategory`.

When you want to answer "what type of descriptor range should this parameter use?"
you should use `SlangBindingType`.
*/
public enum SlangBindingType : uint
{
    UNKNOWN = 0,

    SAMPLER,
    TEXTURE,
    CONSTANT_BUFFER,
    PARAMETER_BLOCK,
    TYPED_BUFFER,
    RAW_BUFFER,
    COMBINED_TEXTURE_SAMPLER,
    INPUT_RENDER_TARGET,
    INLINE_UNIFORM_DATA,
    RAY_TRACING_ACCELERATION_STRUCTURE,

    VARYING_INPUT,
    VARYING_OUTPUT,

    EXISTENTIAL_VALUE,
    PUSH_CONSTANT,

    MUTABLE_FLAG = 0x100,

    MUTABLE_TETURE =
        TEXTURE | MUTABLE_FLAG,
    MUTABLE_TYPED_BUFFER =
        TYPED_BUFFER | MUTABLE_FLAG,
    MUTABLE_RAW_BUFFER =
        RAW_BUFFER | MUTABLE_FLAG,

    BASE_MASK = 0x00FF,
    EXT_MASK = 0xFF00,
}


public enum SlangLayoutRules : uint
{
    DEFAULT,
    METAL_ARGUMENT_BUFFER_TIER_2,
};


public enum SlangModifierID : uint
{
    SHARED,
    NO_DIFF,
    STATIC,
    CONST,
    EXPORT,
    EXTERN,
    DIFFERENTIABLE,
    MUTATING,
    IN,
    OUT,
    INOUT
};


public enum SlangImageFormat : uint
{
    unknown,
    rgba32f,
    rgba16f,
    rg32f,
    rg16f,
    r11f_g11f_b10f,
    r32f,
    r16f,
    rgba16,
    rgb10_a2,
    rgba8,
    rg16,
    rg8,
    r16,
    r8,
    rgba16_snorm,
    rgba8_snorm,
    rg16_snorm,
    rg8_snorm,
    r16_snorm,
    r8_snorm,
    rgba32i,
    rgba16i,
    rgba8i,
    rg32i,
    rg16i,
    rg8i,
    r32i,
    r16i,
    r8i,
    rgba32ui,
    rgba16ui,
    rgb10_a2ui,
    rgba8ui,
    rg32ui,
    rg16ui,
    rg8ui,
    r32ui,
    r16ui,
    r8ui,
    r64ui,
    r64i,
    bgra8,
}


public enum CompileCoreModuleFlags : uint
{
    WriteDocumentation = 0x1,
}

public enum BuiltinModuleName : int
{
    Core,
    GLSL
}


public enum ContainerType : int
{
    None,
    UnsizedArray,
    StructuredBuffer,
    ConstantBuffer,
    ParameterBlock
};


// Passed into functions to create globalSession to identify the API version client code is
// using.

public enum SlangLanguageVersion
{
    VERSION_2025 = 2025
};


public enum SessionFlags : uint
{
    None = 0
};
